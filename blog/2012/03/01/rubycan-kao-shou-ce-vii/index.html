
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>ruby参考手册VII  - Francis's Octopress Blog</title>
  <meta name="author" content="Francis Jiang">

  
  <meta name="description" content="ruby参考手册VII Ruby FAQ 一般的问题
变量、常数、参数
调用带块方法（迭代器）
句法
方法
类、模块
内部库
扩展库
尚未列出的功能
日语字符的处理
Ruby的处理系统 一般的问题 1.1 Ruby是什么？
1.2 为什么取名叫Ruby呢？
1.3 请介绍一下Ruby的诞生过程
1 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jhjguxin.github.io/blog/2012/03/01/rubycan-kao-shou-ce-vii">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Francis's Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-25901353-3']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Francis's Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jhjguxin.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/readme">Readme</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">ruby参考手册VII</h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-01T00:07:00+08:00" pubdate data-updated="true">Mar 1<span>st</span>, 2012</time>
        
      </p>
    
  </header>


<div class="entry-content"><h2>ruby参考手册VII</h2>

<p>Ruby FAQ</p>

<ol>
<li>一般的问题</li>
<li>变量、常数、参数</li>
<li>调用带块方法（迭代器）</li>
<li>句法</li>
<li>方法</li>
<li>类、模块</li>
<li>内部库</li>
<li>扩展库</li>
<li>尚未列出的功能</li>
<li>日语字符的处理</li>
<li>Ruby的处理系统</li>
</ol>


<p>一般的问题</p>

<ul>
<li>1.1 Ruby是什么？</li>
<li>1.2 为什么取名叫Ruby呢？</li>
<li>1.3 请介绍一下Ruby的诞生过程</li>
<li>1.4 哪里有Ruby的安装文件？</li>
<li>1.5 请问Ruby的主页在哪里？</li>
<li>1.6 请问有Ruby邮件列表吗？</li>
<li>1.7 怎么才能看到邮件列表中的老邮件？</li>
<li>1.8 rubyist和ruby hacker的区别是什么？</li>
<li>1.9 它的正确写法是&#8221;Ruby&#8221;还是&#8221;ruby&#8221;？</li>
<li>1.10 请介绍一些Ruby的参考书</li>
<li>1.11 我看了手册可还是不明白，该怎么办？</li>
<li>1.12 ruby的性格比较像羊？</li>
<li>1.13 遇到bug时怎么上报？</li>
</ul>


<p>变量、常数、参数</p>

<ul>
<li>2.1 将对象赋值给变量或常数时,会先拷贝该对象吗?</li>
<li>2.2 局部变量的作用域是如何划定的?</li>
<li>2.3 何时才能使用局部变量?</li>
<li>2.4 常数的作用域是如何划定的?</li>
<li>2.5 实参是怎么传递给形参的呢?</li>
<li>2.6 将实参赋值给形参之后,对实参本身有什么影响吗?</li>
<li>2.7 若向形参所指对象发送消息的话,可能出现什么结果?</li>
<li>2.8 参数前面的*是什么意思?</li>
<li>2.9 参数前面的&amp;代表什么?</li>
<li>2.10 可以给形参指定默认值吗?</li>
<li>2.11 如何向块传递参数呢?</li>
<li>2.12 为什么变量和常数的值会自己发生变化?</li>
<li>2.13 常数不能被修改吗?</li>
</ul>


<p>调用带块方法</p>

<ul>
<li>3.1 什么是&#8221;带块的方法调用&#8221;?</li>
<li>3.2 怎么将块传递给带块方法?</li>
<li>3.3 如何在主调方法中使用块?</li>
<li>3.4 为什么Proc.new没有生成过程对象呢?</li>
</ul>


<p>句法</p>

<ul>
<li>4.1 像:exit这种带:的标识符表示什么？</li>
<li>4.2 如何取得与符号同名的变量的值？</li>
<li>4.3 loop是控制结构吗？</li>
<li>4.4 a +b报错，这是怎么回事儿？</li>
<li>4.5 s = &ldquo;x&rdquo;; puts s *10 报错，这是怎么回事儿？</li>
<li>4.6 为什么p {}没有任何显示呢？</li>
<li>4.7 明明有pos=()这样的setter方法，可为什么pos=1时却没有任何反应呢？</li>
<li>4.8 &lsquo;\1&#8217;和&rsquo;\1&#8217;有什么不同？</li>
<li>4.9 在p true or true an<span>d</span> false中会显示true，但在a=true if true or true and false中却不会把true赋值给a。</li>
<li>4.10 为什么p(nil || &ldquo;&rdquo;)什么事儿都没有，可p(nil or &ldquo;&rdquo;)却会报错呢？</li>
</ul>


<p>方法</p>

<ul>
<li>5.1 向对象发出消息之后，将按照什么顺序来搜索要执行的方法？</li>
<li>5.2 +和-是操作符吗？</li>
<li>5.3 Ruby中有函数吗？</li>
<li>5.4可以在外部使用对象的实例变量吗？</li>
<li>5.5 private和protected有什么不同？</li>
<li>5.6 能不能将实例变量变成public类型的变量？</li>
<li>5.7 怎样指定方法的可见性？</li>
<li>5.8 方法名可以用大写字母开头吗？</li>
<li>5.9 为什么使用super时会出现ArgumentError?</li>
<li>5.10 如何调用上2层的同名方法？</li>
<li>5.11 重定义内部函数时，如何调用原来的函数？</li>
<li>5.12 何谓破环性的方法？</li>
<li>5.13 那些情况下会产生副作用？</li>
<li>5.14 能让方法返回<span>多个值</span>吗？</li>
</ul>


<p>类、模块</p>

<ul>
<li>6.1 重定义类时，是否会覆盖原来的定义？</li>
<li>6.2 有类变量吗？</li>
<li>6.3 什么是类的实例变量？</li>
<li>6.4 什么是特殊方法？</li>
<li>6.5 什么是类方法？</li>
<li>6.6 什么是特殊类？</li>
<li>6.7 什么是模块函数？</li>
<li>6.8 类和模块有什么区别？</li>
<li>6.9 模块可以生成子类吗？</li>
<li>6.10 在类定义中定义类方法 和 在顶层中定义类方法 之间有什么不同？</li>
<li>6.11 load和require有什么不同？</li>
<li>6.12 include和extend有什么不同？</li>
<li>6.13 self是什么？</li>
<li>6.14 MatchData中的begin、end分别返回什么？</li>
<li>6.15 如何使用类名来获得类？</li>
</ul>


<p>内部库</p>

<ul>
<li>7.1 instance_methods(true)返回什么?</li>
<li>7.2 为什么rand总是生成相同的随机数?</li>
<li>7.3 怎样从0到51中选出5个不重复的随机数呢?</li>
<li>7.4 Fixnum、Symbol、true、nil和false这些立即值与引用有什么不同?</li>
<li>7.5 nil和false有什么不同?</li>
<li>7.6 为什么读入文件并修改之后, 原文件依然没有变化?</li>
<li>7.7 怎样覆盖同名文件?</li>
<li>7.8 写文件后拷贝该文件,但所得副本并不完整,请问原因何在?</li>
<li>7.9 在管道中将字符串传给less后, 为什么看不到结果?</li>
<li>7.10 无法引用的File对象将会何去何从?</li>
<li>7.11 怎样手动关闭文件?</li>
<li>7.12 如何按照更新时间的新旧顺序来排列文件?</li>
<li>7.13 如何获取文件中单词的出现频度?</li>
<li>7.14 为什么条件表达式中的空字符串表示true呢?</li>
<li>7.15 如何按照字典顺序来排列英文字符串数组?</li>
<li>7.16 &ldquo;abcd&rdquo;[0]会返回什么?</li>
<li>7.17 怎么把tab变成space?</li>
<li>7.18 如何对反斜线进行转义操作?</li>
<li>7.19 sub和sub!的区别在哪里?</li>
<li>7.20 \Z匹配什么？</li>
<li>7.21 范围对象中的..和&hellip;有什么不同?</li>
<li>7.22 有函数指针吗?</li>
<li>7.23 线程和进程fork有何异同？</li>
<li>7.24 如何使用Marshal？</li>
<li>7.25 Ruby有异常处理语句吗?</li>
<li>7.26 如何使用trap？</li>
<li>7.27 如何统计文件的行数？</li>
<li>7.28 怎样把数组转化为哈希表？</li>
<li>7.29 将字符串变为Array时可以使用%w(&hellip;)，那么将字符串变为Hash时能不能如法炮制呢？</li>
<li>7.30 为何无法捕捉NameError异常呢？</li>
<li>7.31 为什么有succ却没有prev呢</li>
</ul>


<p>扩展库</p>

<ul>
<li>8.1 如何使用交互式Ruby？</li>
<li>8.2 有调试器吗？</li>
<li>8.3 怎样在Ruby中使用以C写成的库？</li>
<li>8.4 有Tcl/Tk的接口吗？</li>
<li>8.5 为什么我的Tk不管用？</li>
<li>8.6 有gtk+、xforms的接口吗？</li>
<li>8.7 进行日期计算时需要注意哪些问题？</li>
</ul>


<p>尚未列出的功能
日语字符的处理</p>

<ul>
<li>10.1 若包含汉字的脚本输出乱码或无法正常运行时，该如何处理？</li>
<li>10.2 选项-K和$KCODE有什么不同？</li>
<li>10.3 可以使用日语标识符吗？</li>
<li>10.4 如何从包含日语字符的字符串中依次抽出1个字符？</li>
<li>10.5 tr(&ldquo;あ&rdquo;,&ldquo;a&rdquo;)运作不正常，应如何处置？</li>
<li>10.6 如何对平假名进行排序？</li>
<li>10.7 如何用空白来替代SJIS中从84BF到889F之间的系统相关代码？</li>
<li>10.8 如何进行全角－半角字符的变换？</li>
<li>10.9 关于半角假名的问题</li>
<li>10.10 怎样从包含日语字符的字符串中抽出n字节的内容？</li>
<li>10.11 怎么让日语文本在第n个字处换行？</li>
</ul>


<p>Ruby的处理系统</p>

<ul>
<li>11.1 能不能编译Ruby脚本呢？</li>
<li>11.2 有没有Java VM版的Ruby？</li>
<li>11.3 除了original Ruby之外，就没有其他版本吗？</li>
<li>11.4 有没有Ruby用的indent？</li>
<li>11.5 有没有使用本地线程的Ruby？</li>
<li>11.6 GC实在是太慢了，怎么办才好？</li>
<li><p>11.7 有没有Mac版的Ruby？</p></li>
<li><p>一般的问题</p></li>
<li><p>1.1 Ruby是什么？</p></li>
<li>1.2 为什么取名叫Ruby呢？</li>
<li>1.3 请介绍一下Ruby的诞生过程</li>
<li>1.4 哪里有Ruby的安装文件？</li>
<li>1.5 请问Ruby的主页在哪里？</li>
<li>1.6 请问有Ruby邮件列表吗？</li>
<li>1.7 怎么才能看到邮件列表中的老邮件？</li>
<li>1.8 rubyist和ruby hacker的区别是什么？</li>
<li>1.9 它的正确写法是&#8221;Ruby&#8221;还是&#8221;ruby&#8221;？</li>
<li>1.10 请介绍一些Ruby的参考书</li>
<li>1.11 我看了手册可还是不明白，该怎么办？</li>
<li>1.12 ruby的性格比较像羊？</li>
<li>1.13 遇到bug时怎么上报？</li>
</ul>


<p>1.1 Ruby是什么？</p>

<p>一言以蔽之，Ruby是一种</p>

<p>语法简单且功能强大的面向对象的脚本语言。</p>

<p>与perl一样，Ruby的文本处理功能十分强大。当然了它的功能远不止于此，您还可以使用它来开发实用的服务器软件。</p>

<p>Ruby博采众长，吸收了众多语言的优点，却又别具一格。</p>

<p>Ruby的优点主要体现在以下几个方面。</p>

<ul>
<li>它的语法简单</li>
<li>它具有普通的面向对象功能(类、方法调用等)</li>
<li>它还具有特殊的面向对象功能(Mix-in、特殊方法等)</li>
<li>可重载操作符</li>
<li>具有异常处理功能</li>
<li>调用带块方法(迭代器)和闭包</li>
<li>垃圾回收器</li>
<li>动态载入(取决于系统架构)</li>
<li>可移植性。它可以运行在大部分的UNIX、DOS和Mac上</li>
</ul>


<p>1.2 为什么取名叫Ruby呢？</p>

<p>松本先生曾经在[ruby-talk:00394]<a href="June%2011,%201999">英译稿</a>中讲过取名的经过。</p>

<p>据说当初松本先生一直琢磨着要给这个新语言取个像Perl这样的宝石名字，正好有个同事的诞生石是Ruby，因此就取名叫Ruby了。</p>

<p>后来发现Ruby和Perl真的很投缘，例如pearl诞生石代表6月，而ruby诞生石则代表7月。还有pearl的字体大小是5pt，而ruby则是5.5pt等等。因此松本先生觉得Ruby这个名字很合适，并努力使其成为比Perl更新更好的脚本语言。</p>

<p>松本先生正期待着Ruby取代Perl的那一天早点到来(^^)。
1.3 请介绍一下Ruby的诞生过程</p>

<p>松本先生曾经在[ruby-talk:00382]<a href="June%204,%201999">英译稿</a>中介绍过Ruby的诞生过程。[ruby-list:15997]修改了Ruby的诞生时间。</p>

<p>*</p>

<p>Ruby诞生于1993年2月24日。那天我和同事们聊了聊面向对象语言的可能性问题。我了解Perl(Perl4而非Perl5)，但我不喜欢它身上的那股玩具味儿(现在也是如此)。面向对象的脚本语言的前途一片光明。</p>

<p>我觉得Python不能算作真正的面向对象语言，因为它的面向对象特性好像是后加进去的一样。15年来我一直为编程语言而痴狂，我热衷于面向对象编程，但却没有找到一款真正意义上的面向对象的脚本语言。</p>

<p>于是我下定决心自己来开发一个。经过几个月的努力，解释器终于开发成功。然后我又添加了一些自己梦寐以求的东西，如迭代器、异常处理、垃圾回收等。</p>

<p>后来我又采用类库方式添加了Perl的特性。1995年12月，我在日本国内的新闻组上发布了Ruby 0.95版本。</p>

<p>接下来我创建了邮件列表和网站。此后，大家在邮件列表中聊得酣畅淋漓。时至今日，第一个邮件列表中已经积累了14789封邮件。</p>

<p>Ruby 1.0发布于1996年12月，1.1发布于1997年8月。1998年12月，我又发布了安定版1.2和开发版1.3。</p>

<p>1.4 哪里有Ruby的安装文件？</p>

<p>您可以在这里&lt;URL:<a href="ftp://ftp.ruby-lang.org/pub/ruby/&amp;gt;%E6%89%BE%E5%88%B0%E6%9C%80%E6%96%B0%E7%89%88%E7%9A%84Ruby%E3%80%82">ftp://ftp.ruby-lang.org/pub/ruby/&amp;gt;%E6%89%BE%E5%88%B0%E6%9C%80%E6%96%B0%E7%89%88%E7%9A%84Ruby%E3%80%82</a></p>

<p>镜像站点列表如下</p>

<ul>
<li>&lt;URL:<a href="ftp://ftp.TokyoNet.AD.JP/pub/misc/ruby/&amp;gt;">ftp://ftp.TokyoNet.AD.JP/pub/misc/ruby/&amp;gt;</a></li>
<li>&lt;URL:<a href="ftp://ftp.iij.ad.jp/pub/lang/ruby/&amp;gt;">ftp://ftp.iij.ad.jp/pub/lang/ruby/&amp;gt;</a></li>
<li>&lt;URL:<a href="ftp://blade.nagaokaut.ac.jp/pub/lang/ruby/&amp;gt;">ftp://blade.nagaokaut.ac.jp/pub/lang/ruby/&amp;gt;</a></li>
<li>&lt;URL:<a href="ftp://ftp.krnet.ne.jp/pub/ruby/&amp;gt;">ftp://ftp.krnet.ne.jp/pub/ruby/&amp;gt;</a></li>
<li>&lt;URL:<a href="ftp://mirror.nucba.ac.jp/mirror/ruby/&amp;gt;">ftp://mirror.nucba.ac.jp/mirror/ruby/&amp;gt;</a></li>
<li>&lt;URL:<a href="http://mirror.nucba.ac.jp/mirror/ruby/&amp;gt;">http://mirror.nucba.ac.jp/mirror/ruby/&amp;gt;</a></li>
</ul>


<p>您可以在Ruby Binaries中找到cygwin版、mingw版和djgpp版的二进制文件包。</p>

<p>另外，Windows(cygwin)中还为初学者准备了Ruby Entry Package。安装方法请参考面向初学者的Ruby安装说明。
1.5 请问Ruby的主页在哪里？</p>

<p>Ruby的官方网站是&lt;URL:<a href="http://www.ruby-lang.org/&amp;gt;%E3%80%82">http://www.ruby-lang.org/&amp;gt;%E3%80%82</a>
1.6 请问有Ruby邮件列表吗？</p>

<p>现在有6个正式的Ruby邮件列表。</p>

<ul>
<li>ruby-list</li>
<li>ruby-dev</li>
<li>ruby-ext</li>
<li>ruby-math</li>
<li>ruby-talk</li>
<li>ruby-core</li>
</ul>


<p>详情请参考Ruby邮件列表。
1.7 怎么才能看到邮件列表中的老邮件？</p>

<p>&lt;URL:<a href="http://blade.nagaokaut.ac.jp/ruby/ruby-list/index.shtml&amp;gt;%E5%92%8C&amp;lt;URL:http://ruby.freak.ne.jp/&amp;gt;%E9%87%8C%E9%9D%A2%E6%9C%89%E6%90%9C%E7%B4%A2%E9%82%AE%E4%BB%B6%E7%94%A8%E7%9A%84%E8%A1%A8%E5%8D%95%E3%80%82">http://blade.nagaokaut.ac.jp/ruby/ruby-list/index.shtml&amp;gt;%E5%92%8C&amp;lt;URL:http://ruby.freak.ne.jp/&amp;gt;%E9%87%8C%E9%9D%A2%E6%9C%89%E6%90%9C%E7%B4%A2%E9%82%AE%E4%BB%B6%E7%94%A8%E7%9A%84%E8%A1%A8%E5%8D%95%E3%80%82</a></p>

<p>另外，ML Topics中列出了老邮件中的重要话题。
1.8 rubyist和ruby hacker的区别是什么？</p>

<p>松本先生对rubyist和Ruby hacker的定义如下。</p>

<p>rubyist是指那些对Ruby的关心程度超过常人的人。例如</p>

<ul>
<li>向周围的人宣传Ruby的人</li>
<li>编写Ruby的FAQ的人</li>
<li>在计算机通信组中增加Ruby小组的组长</li>
<li>撰写Ruby书籍的作者</li>
<li>写信鼓励Ruby作者的热心人</li>
<li>Ruby作者本人 ^^;;;</li>
</ul>


<p>而Ruby hacker是指那些在技术层面上对Ruby有所专攻的人。例如</p>

<ul>
<li>Ruby扩展库的作者</li>
<li>修改Ruby中的bug并发布补丁的人</li>
<li>djgpp版Ruby或win32版Ruby的作者</li>
<li>用Ruby编写了实用(必须得具备一定规模的)程序的人</li>
<li>用Ruby编写出天书般难懂的脚本的人</li>
<li>Ruby作者本人 ^^;;;</li>
</ul>


<p>等就是Ruby hacker。</p>

<p>这些称号只不过是自我解嘲式的自称，我不会为任何人进行正式的认证。松本先生特别将上述人士列为{rubyist、Ruby hacker}，可见其尊敬之情。
1.9 它的正确写法是&#8221;Ruby&#8221;还是&#8221;ruby&#8221;？</p>

<p>Ruby的正式写法是&#8221;Ruby&#8221;，其命令名是&#8221;ruby&#8221;。另外只要不让人觉得别扭的话，也可以使用ruby来替代Ruby。</p>

<p>但不能把&#8221;RUBY&#8221;、&#8221;ルビー&#8221;或&#8221;るびー&#8221;用作这门语言的名称。</p>

<p>此前曾经有一段时间把&#8221;ruby&#8221;用作正式名称。
1.10 请介绍一些Ruby的参考书</p>

<p>主要有《オブジェクト指向スクリプト言語Ruby》(译注:日语书名未翻译)[松本行弘／石塚圭树 合著 ASCII出版(ISBN4-7561-3254-5)]，其他书目请参考Ruby相关书籍。</p>

<p>至于正则表达式，请参考Jeffrey E. F.Friedl著的《詳説正規表現》(译注:日语书名未翻译)[reilly Japan出版(ISBN4-900900-45-1)]。这本书介绍了各种正则表达式的实现问题，有助于加深您对于Ruby正则表达式的理解。
1.11 我看了手册可还是不明白，该怎么办？</p>

<p>Ruby的基本句法从Ruby1.0以后就没有太大的变化，但却在不断完善和扩充，因此有时文档的更新速度跟不上最新的发展。另外，有人坚持说源代码就是文档，如此种种。</p>

<p>若您有何疑问，请不必顾虑太多，直接到ruby-list中提问即可。Ruby教主松本先生以及各位尊师还有我都会为您排忧解难。</p>

<p>提问时，请写明ruby -v的结果并附带上您的代码(若代码太长的话，只需摘录重要部分即可)。</p>

<p>若您使用的是irb的话，则稍有不同。因为irb自身也存在一些问题，所以您最好先用irb &mdash;single-irb重试一下，或者用ruby重新运行一次为好。</p>

<p>虽然搜索ML可以解决您的大部分问题，但因为邮件数量庞大，想找到答案实属不易。为遵从网络礼节(请参考RFC1855的3.1.1、3.1.2)，您可以只搜索最近的内容，但是说起来容易，做起来难。况且说不定最近又出现了什么新观点呢。所以您还是壮起胆子来提问吧。
1.12 ruby的性格比较像羊？</p>

<p>羊、蜂鸟、兔子&hellip;
1.13 遇到bug时怎么上报？</p>

<p>遇到bug时应该上报到Ruby Bug Tracking System，通常很快就会得到回复。您也可以用邮件将bug的情况上报到ruby-bugs-ja。</p>

<p>上报时，最好能提供ruby的版本和平台信息、错误消息以及能再现bug的脚本和数据。</p>

<p>遇到bug时，通常会显示[BUG]消息，而Ruby也将被强行关闭。此时大部分系统都会生成一个core文件。若您的调试器可用的话，可能还会有backtrace。若您能提供这些信息就更好了。</p>

<ol>
<li><p>变量、常数、参数</p></li>
<li><p>2.1 将对象赋值给变量或常数时,会先拷贝该对象吗?</p></li>
<li>2.2 局部变量的作用域是如何划定的?</li>
<li>2.3 何时才能使用局部变量?</li>
<li>2.4 常数的作用域是如何划定的?</li>
<li>2.5 实参是怎么传递给形参的呢?</li>
<li>2.6 将实参赋值给形参之后,对实参本身有什么影响吗?</li>
<li>2.7 若向形参所指对象发送消息的话,可能出现什么结果?</li>
<li>2.8 参数前面的*是什么意思?</li>
<li>2.9 参数前面的&amp;代表什么?</li>
<li>2.10 可以给形参指定默认值吗?</li>
<li>2.11 如何向块传递参数呢?</li>
<li>2.12 为什么变量和常数的值会自己发生变化?</li>
<li>2.13 常数不能被修改吗?</li>
</ol>


<p>2.1 将对象赋值给变量或常数时,会先拷贝该对象吗?</p>

<p>变量和常数都指向一个对象。即使不赋值, 它也是指向nil对象的。赋值操作只不过是让它指向另一个新对象而已。</p>

<p>所以, 赋值时并不会拷贝并生成一个新对象. 而是让赋值表达式左边的变量或常数指向表达式右边的对象。</p>

<p>尽管如此, 可能还是有人不理解. 这也是情有可原的, 因为上面的解释并不能涵盖所有的情况. 实际上, Fixnum、NilClass、 TrueClass、FalseClass以及Symbol类的实例会被变量或常数直接保存, 所以赋值时会被拷贝。其他类的实例都在内存上的其他地方, 变量和常数会指向它们。请参考立即值和使用。
2.2 局部变量的作用域是如何划定的?</p>

<p>顶层、类(模块)定义或方法定义都是彼此独立的作用域。另外, 在块导入新的作用域时, 它还可以使用外侧的局部变量。</p>

<p>块之所以与众不同, 是因为这样能够保证Thread或过程对象中的局部变量的&#8221;局部性&#8221;。while、until、for是控制结构, 它们不会导入新的作用域。另外, loop是方法, 它的后面跟着块。
2.3 何时才能使用局部变量?</p>

<p>在Ruby解释器运行Ruby脚本时, 它会一次读取整个脚本,然后进行语法分析。若没有语法问题的话, 才会开始执行句法分析中得到的代码。</p>

<p>在进行语法分析时, 只有在遇到局部变量的赋值语句之后, 才能使用它。例如</p>

<p>for i in 1..2
if i == 2
print a
else
a = 1
end
end</p>

<p>把上述代码写入名为test.rb的脚本. 执行该脚本后发生如下错误</p>

<p>test.rb:3: undefined local variable or method `a&#8217; for</p>

<h1>&lt;Object:0x40101f4c&gt; (NameError)</h1>

<p>from test.rb:1:in `each&#8217;
from test.rb:1</p>

<p>当i值为1时,并不会发生错误;当i变成2之后就不行了。这是因为, 在进行语法分析时并不会按照运行时的逻辑顺序来进行, 而只是机械地逐行分析. 在遇到print a语句时, a并未被赋值, 因而无法使用该局部变量. 之后,在运行时因为找不到名为a的方法, 所以发生错误。</p>

<p>相反地, 若使用如下脚本则不会出现错误。</p>

<p>a = 1 if false; print a</p>

<h1>=&gt; nil</h1>

<p>若您不想因为局部变量的这个特性而费神的话, 我们推荐您在使用局部变量之前, 添加a = nil赋值语句。这样作还有一个好处, 就是可以加快局部变量的使用速度。
2.4 常数的作用域是如何划定的?</p>

<p>类/模块中定义的常数可以用在该类/模块中。</p>

<p>若类/模块定义发生嵌套时, 可在内侧类/模块中使用外侧的常数。</p>

<p>还可以使用超类以及包含模块中的常数。</p>

<p>因为顶层中定义的常数已经被添加到Object类中, 所以您可以在所有的类/模块中使用顶层中的常数。</p>

<p>若遇到无法直接使用的常数时, 可以使用 类/模块名+::操作符+常数名 的方式来使用它。
2.5 实参是怎么传递给形参的呢?</p>

<p>方法调用时, 会把实参赋值给形参。请您参考向变量进行赋值来了解Ruby中赋值的含义。若实参中的对象包含可以改变自身状态的方法时,就必须注意其副作用(当然了,也有可能不是副作用)了。请参考破坏性的方法。
2.6 将实参赋值给形参之后,对实参本身有什么影响吗?</p>

<p>形参是局部变量, 对其进行赋值之后, 它就会指向其他对象. 仅此而已, 它并不会对原来的实参有什么影响。
2.7 若向形参所指对象发送消息的话,可能出现什么结果?</p>

<p>形参所指对象实际上就是实参所指对象. 若该对象接到消息时状态发生变化的话,将会影响到主调方。请参考破坏性的方法。
2.8 参数前面的*是什么意思?</p>

<p>各位C语言大侠请看好, 这可不是什么指针。在Ruby的参数前面添加一个*表示, 它可以接受以数组形式传来的不定量的参数。</p>

<p>def foo(*all)
for e in all
print e, &ldquo; &rdquo;
end
end</p>

<p>foo(1, 2, 3)</p>

<h1>=&gt; 1 2 3</h1>

<p>另外,如果在方法调用中传了一个带*的数组, 则表示先展开数组然后再进行传递。</p>

<p>a = [1, 2, 3]
foo(*a)</p>

<p>现在只能在以下部分的尾部使用*</p>

<ol>
<li>多重赋值的左边</li>
<li>多重赋值的右边</li>
<li>参数列表(定义方法时)</li>
<li>参数列表(调用方法时)</li>
<li>case的when部分</li>
</ol>


<p>下面是在第(1)种形式中使用*的例子</p>

<p>x, *y = [7, 8, 9]</p>

<p>上面的代码相当于x = 7、y = [8, 9]。另外,下面的代码</p>

<p>x, = [7, 8, 9]</p>

<p>也是合法的, 此时x = 7. 而</p>

<p>x = [7, 8, 9]</p>

<p>则表示x = [7, 8, 9]。
2.9 参数前面的&amp;代表什么?</p>

<p>在参数前面添加&amp;之后,就可以像使用块那样来传递/接收过程对象。它只能位于参数列表的末尾。
2.10 可以给形参指定默认值吗?</p>

<p>可以。</p>

<p>在调用函数时,才会计算该默认值。您可以使用任意表达式来设定Ruby的默认值(C++只能使用编译时的常数). 调用方法时,会在方法的作用域内计算默认值。
2.11 如何向块传递参数呢?</p>

<p>在块内部的前端,使用||将形参括起来之后, 就可以使用实参进行多重赋值了。该形参只是普通的局部变量, 若块的外侧已经有同名参数时, 块参数的作用域将扩大到块外侧, 请留意这个问题。
2.12 为什么变量和常数的值会自己发生变化?</p>

<p>请看下例。</p>

<p>A = a = b = &ldquo;abc&rdquo;; b &lt;&lt; &ldquo;d&rdquo;; print a, &ldquo; &rdquo;, A</p>

<h1>=&gt; abcd abcd</h1>

<p>对变量或常数进行赋值, 是为了以后通过它们来使用对象。这并不是将对象本身赋值给变量或常数, 而只是让它们记住对该对象的引用。变量可以修改这个引用来指向其他的对象, 而常数却不能修改引用。</p>

<p>对变量或常数使用方法时, 实际上就是对它们所指的对象使用该方法。在上例中, &lt;&lt;方法修改了对象的状态,所以引发了&#8221;非预期&#8221;的结果。若该对象是数值的话, 就不会发生这种问题, 因为数值没有修改其自身状态的方法。若对数值使用方法时, 将返回新的对象。</p>

<p>这个例子虽然是用字符串来作演示的, 但就算使用带有可修改自身状态的方法的那些对象, 如数组或哈希表等来试验的话, 效果也是一样的。
2.13 常数不能被修改吗?</p>

<p>若想让指向某对象的常数转而指向其他对象时, 就会出现warning。</p>

<p>若该对象带有破坏性的方法的话, 则可以修改该对象的内容。</p>

<ol>
<li><p>带块的方法调用</p></li>
<li><p>3.1 什么是&#8221;带块的方法调用&#8221;?</p></li>
<li>3.2 怎么将块传递给带块方法?</li>
<li>3.3 如何在主调方法中使用块?</li>
<li>3.4 为什么Proc.new没有生成过程对象呢?</li>
</ol>


<p>3.1 什么是&#8221;带块的方法调用&#8221;?</p>

<p>有些方法允许在调用它的过程中添加块或者过程对象, 这种特殊的方法调用就是&#8221;带块的方法调用&#8221;。</p>

<p>这原本是为了对控制结构(特别是循环)进行抽象而设置的功能, 因此有时也被称作迭代器. 当然了, 若您只想调用块而不进行iterate(迭代)操作时,也可以使用它.</p>

<p>下例中就用到了迭代器。</p>

<p>data = [1, 2, 3]
data.each do |i|
print i, &ldquo;\n&rdquo;
end</p>

<p>它会输出如下内容。</p>

<p>$ ruby test.rb
1
2
3</p>

<p>也就是说,do和end之间的块被传递给方法, 供其差遣。each方法分别为data中的每个元素来执行块的内容。</p>

<p>用C语言来改写的话,就是</p>

<p>int data[3] = {1, 2, 3};
int i;
for (i = 0; i &lt; 3; i++) {
printf(&ldquo;%d\n&rdquo;, data[i]);
}</p>

<p>用for来编写代码时, 必须自己进行迭代处理. 相反地, 使用带块的方法调用时, 则由方法负责处理, 这大大减少了因误判循环边界而导致bug的可能性。</p>

<p>另外, 除了do&hellip;end之外, 您还可以使用{&hellip;}。</p>

<p>data = [1, 2, 3]
data.each { |i|
print i, &ldquo;\n&rdquo;
}</p>

<p>这段代码与前面的完全等效。但这并不标明do&hellip;end与{&hellip;}完全等效。例如</p>

<p>foobar a, b do .. end # 此时foobar被看做是带块的方法
foobar a, b { .. } # 而此时 b被看做是带块的方法</p>

<p>这说明{ }的结合力大于do块。
3.2 怎么将块传递给带块方法?</p>

<p>如果想将块传递给带块方法, 只需要将块放在方法后面即可. 另外, 还可以在表示过程对象的变量/常数前添加&amp;, 并将其作为参数传递给方法即可。
3.3 如何在主调方法中使用块?</p>

<p>有3种方式可以让您在方法中使用块. 它们分别是yield控制结构、块参数和Proc.new。(在由C语言写成的扩展库中,需要使用rb_yield)</p>

<p>使用yield时, yield后面的参数会被传递给块, 然后执行块的内容。</p>

<p>块参数是指,插在方法定义中的参数列表末尾的 形如&amp;method的参数. 可以在方法中,这样method.call(args&hellip;)来进行调用。</p>

<p>使用Proc.new时, 它会接管传递给方法的块, 并以块的内容为范本生成一个过程对象。proc或lamda也是一样。</p>

<p>def a (&amp;b)
yield
b.call
Proc.new.call
proc.call
lambda.call
end
a{print &ldquo;test\n&rdquo;}</p>

<p>3.4 为什么Proc.new没有生成过程对象呢?</p>

<p>若没有给出块的话, Proc.new是不会生成过程对象的, 而且还会引发错误。在方法定义中插入Proc.new时, 一般都假定在方法调用时会传过来一个块。</p>

<ol>
<li><p>句法</p></li>
<li><p>4.1 像:exit这种带:的标识符表示什么？</p></li>
<li>4.2 如何取得与符号同名的变量的值？</li>
<li>4.3 loop是控制结构吗？</li>
<li>4.4 a +b报错，这是怎么回事儿？</li>
<li>4.5 s = &ldquo;x&rdquo;; puts s *10 报错，这是怎么回事儿？</li>
<li>4.6 为什么p {}没有任何显示呢？</li>
<li>4.7 明明有pos=()这样的setter方法，可为什么pos=1时却没有任何反应呢？</li>
<li>4.8 &lsquo;\1&#8217;和&rsquo;\1&#8217;有什么不同？</li>
<li>4.9 在p true or true and false中会显示true，但在a=true if true or true and false中却不会把true赋值给a。</li>
<li>4.10 为什么p(nil || &ldquo;&rdquo;)什么事儿都没有，可p(nil or &ldquo;&rdquo;)却会报错呢？</li>
</ol>


<p>4.1 像:exit这种带:的标识符表示什么？</p>

<p>它叫做符号对象，它与标识符之间是1对1的关系。您也可以使用&#8221;exit&#8221;.intern来得到它。在catch, throw, autoload等方法中，既可以使用字符串参数，又可以使用符号参数。
4.2 如何取得与符号同名的变量的值？</p>

<p>在symbol的作用域内，使用eval((:symbol).id2name)来取值。</p>

<p>a = &lsquo;This is the content of &ldquo;a&rdquo;&rsquo;
b = eval(:a.id2name)
a.id == b.id</p>

<p>4.3 loop是控制结构吗？</p>

<p>不，它是方法。该块会导入新的局部变量的作用域。
4.4 a +b报错，这是怎么回事儿？</p>

<p>它会被解释成a(+b)。+的两侧要么都有空格，要么就都没有。
4.5 s = &ldquo;x&rdquo;; puts s *10 报错，这是怎么回事儿？</p>

<p>puts s <em>10会被解释成s(</em>10)的方法调用，所以要么s*10这样，要么s * 10这样。
4.6 为什么p {}没有任何显示呢？</p>

<p>{}会被解释成块，而并非哈希表的构造函数。所以您需要使用p({})或者p Hash.new来解决这个问题。
4.7 明明有pos=()这样的setter方法，可为什么pos=1时却没有任何反应呢？</p>

<p>请看下例。</p>

<p>class C
attr_reader :pos
def pos=(n)
@pos = n * 3
end</p>

<p>def set
pos = 1 #A行
end
end</p>

<p>a = C.new
a.set
p a.pos #=&gt; nil (预期值是 3)</p>

<p>本来指望最后一行能输出 3，但却是个 nil ，这是因为Ruby把A行的pos解释成局部变量了。若想调用pos=()的话，请这样self.pos = 1调用。
4.8 &lsquo;\1&#8217;和&rsquo;\1&#8217;有什么不同？</p>

<p>没有不同，二者完全一样。在单引号中，只有\&lsquo;、\和行尾的(取消换行)会得到特殊的解释，其他字符不变。
4.9 在p true or true and false中会显示true，但在a=true if true or true and false中却不会把true赋值给a。</p>

<p>第1个表达式会被解释成(p true) or true and false，其中的and/or是构成语句的要素，而并不是用来连接p的参数的操作符。</p>

<p>第2个表达是则会被解释成a=true if (true or true and false)。因为if的优先度低于and/or，且or与and的优先度相同，所以就会从左到右地完成解析。
4.10 为什么p(nil || &ldquo;&rdquo;)什么事儿都没有，可p(nil or &ldquo;&rdquo;)却会报错呢？</p>

<p>虽然||可以连接参数，但or就只能连接句子，所以如此。关于这点区别，您试一试下面的例子就明白了。</p>

<p>p nil || &ldquo;&rdquo;
p nil or &ldquo;&rdquo;</p>

<ol>
<li><p>方法</p></li>
<li><p>5.1 向对象发出消息之后，将按照什么顺序来搜索要执行的方法？</p></li>
<li>5.2 +和-是操作符吗？</li>
<li>5.3 Ruby中有函数吗？</li>
<li>5.4可以在外部使用对象的实例变量吗？</li>
<li>5.5 private和protected有什么不同？</li>
<li>5.6 能不能将实例变量变成public类型的变量？</li>
<li>5.7 怎样指定方法的可见性？</li>
<li>5.8 方法名可以用大写字母开头吗？</li>
<li>5.9 为什么使用super时会出现ArgumentError?</li>
<li>5.10 如何调用上2层的同名方法？</li>
<li>5.11 重定义内部函数时，如何调用原来的函数？</li>
<li>5.12 何谓破环性的方法？</li>
<li>5.13 那些情况下会产生副作用？</li>
<li>5.14 能让方法返回<span>多个值</span>吗？</li>
</ol>


<p>5.1 向对象发出消息之后，将按照什么顺序来搜索要执行的方法？</p>

<p>将依次搜索特殊方法、本类中定义的方法和超类(包括Mix-in进来的模块。写成 类名.ancestors。)中定义的方法，并执行所找到的第一个方法。若没有找到方法时，将按照同样的顺序来搜索method_missing。</p>

<p>mo<span>du</span>le Indexed
def <a href="n"></a>
to_a[n]
end
end
class String
include Indexed
end
p String.ancestors # [String, Indexed, Enumerable, Comparable, Object, Kernel]
p &ldquo;abcde&rdquo;.gsub!(/./, &ldquo;\&amp;\n&rdquo;)[1]</p>

<p>遗憾的是上述代码返回的是10，而并非预期的&#8221;b\n&#8221;。这是因为系统在String类中搜索[]，在遇到Indexed中定义的方法之前就已经完成了匹配，所以如此。若直接在Class String中重定义[]的话，就会如您所愿了。
5.2 +和-是操作符吗？</p>

<p>+和-等是方法调用，而并非操作符。因此可进行overload(重定义)。</p>

<p>class MyString &lt; String
def +(other)
print super(other)
end
end</p>

<p>但以下内容及其组合(!=、!~)则是控制结构，不能进行重定义。</p>

<p>=, .., &hellip;, !, not, &amp;&amp;, and, |, or, ~, ::</p>

<p>重定义(或者定义)操作符时，应该使用形如+@或-@这样的方法名。</p>

<p>=是访问实例变量的方法，您可以在类定义中使用它来定义方法。另外，+或-等经过适当的定义之后，也可以进行形如+=这样的自赋值运算。</p>

<p>def attribute=(val)
@attribute = val
end</p>

<p>5.3 Ruby中有函数吗？</p>

<p>Ruby中看似函数的部分实际上都是些省略被调(self)的方法而已。例如</p>

<p>def writeln(str)
print(str, &ldquo;\n&rdquo;)
end</p>

<p>writeln(&ldquo;Hello, World!&rdquo;)</p>

<p>中看似函数的部分实际上是Object类中定义的方法，它会被发送到隐藏的被调self中。因此可以说Ruby是纯粹的面向对象语言。</p>

<p>对内部函数这种方法来说，不管self如何，它们总是返回相同的结果。因此没有必要计较被调的问题，可以将其看作函数。
5.4 可以在外部使用对象的实例变量吗？</p>

<p>不能直接使用。若想操作实例变量，必须事先在对象中定义操作实例变量的方法(accessor)。例如</p>

<p>class C
def name
@name
end
def name=(str) # name 后面不能有空格！
@name = str
end
end</p>

<p>c = C.new
c.name = &lsquo;山田太郎&rsquo;
p c.name #=&gt; &ldquo;山田太郎&rdquo;</p>

<p>另外，您还可以使用Module#attr、attr_reader、 attr_writer、attr_accessor等来完成这种简单的方法定义。例如，您可以这样来重写上面的类定义。</p>

<p>class C
attr_accessor :name
end</p>

<p>若您不愿定义访问方法，却想使用实例变量时，可以使用Object#instance_eval。
5.5 private和protected有什么不同？</p>

<p>private意味着只能使用函数形式来调用该方法，而不能使用被调形式。所以，您只能在本类或其子类中调用private方法。</p>

<p>protected也是一样，只能用在本类及其子类中。但是您既可以使用函数形式又可以使用被调形式来调用它。</p>

<p>在封装方法时，该功能是必不可少。
5.6 能不能将实例变量变成public类型的变量？</p>

<p>无法让变量变成public类型的变量。在Ruby中访问实例变量时，需要使用访问方法。例如</p>

<p>class Foo
def initialize(str)
@name = str
end</p>

<p>def name
return @name
end
end</p>

<p>但是每次都这么写的话，未免有些繁琐。因此可以使用attr_reader、attr_writer、 attr_accessor等方法来完成这些简单的方法定义。</p>

<p>class Foo
def initialize(str)
@name = str
end</p>

<p>attr_reader :name</p>

<h1>其效果等同于下面的代码。</h1>

<h1>def name</h1>

<h1>return @name</h1>

<h1>end</h1>

<p>end</p>

<p>foo = Foo.new(&ldquo;Tom&rdquo;)
print foo.name, &ldquo;\n&rdquo; # Tom</p>

<p>您还可以使用attr_accessor来同时定义写入的方法。</p>

<p>class Foo
def initialize(str)
@name = str
end</p>

<p>attr_accessor :name</p>

<h1>其效果等同于下面的代码。</h1>

<h1>def name</h1>

<h1>return @name</h1>

<h1>end</h1>

<h1>def name=(str)</h1>

<h1>@name = str</h1>

<h1>end</h1>

<p>end</p>

<p>foo = Foo.new(&ldquo;Tom&rdquo;)
foo.name = &ldquo;Jim&rdquo;
print foo.name, &ldquo;\n&rdquo; # Jim</p>

<p>若只想定义写入方法的话，可以使用attr_writer。
5.7 怎样指定方法的可见性？</p>

<p>首先 Ruby把那些只能以函数形式(省略被调的形式)来调用的方法叫做private方法。请注意，这里的private定义与C++以及Java中的定义不同。</p>

<p>若将方法设为private类型之后，就不能在其它的对象中调用该方法了。因此，若您只想在本类或其子类中调用某方法时， 就可以把它设为private类型。</p>

<p>您可以这样把方法设为private类型。</p>

<p>class Foo
def test
print &ldquo;hello\n&rdquo;
end
private :test
end</p>

<p>foo = Foo.new
foo.test</p>

<h1>=&gt; test.rb:9: private method `test&#8217; called for #&lt;Foo:0x400f3eec&gt;(Foo)</h1>

<p>您可以使用private_class_method将类方法变为private类型。</p>

<p>class Foo
def Foo.test
print &ldquo;hello\n&rdquo;
end
private_class_method :test
end</p>

<p>Foo.test</p>

<h1>=&gt; test.rb:8: private method `test&#8217; called for Foo(Class)</h1>

<p>同理，您可以使用public、public_class_method将方法设为public类型。</p>

<p>在默认情况下，类中的方法都被定义成public类型(initialize除外)，而顶层中的方法会被定义成private类型。
5.8 方法名可以用大写字母开头吗？</p>

<p>可以。但要注意：即使方法调用中不带参数，也不能省略方法名后的空括号。
5.9 为什么使用super时会出现ArgumentError?</p>

<p>在方法定义中调用super时，会把所有参数都传给上层方法，若参数个数不符合其要求，就会引发ArgumentError。因此，若参数个数不合时，应该自己指定参数然后再调用super。
5.10 如何调用上2层的同名方法？</p>

<p>super只能调用上1层的同名方法。若想调用2层以上的同名方法时，需要事先对该上层方法进行alias操作。
5.11 重定义内部函数时，如何调用原来的函数？</p>

<p>可以在方法定义中使用super。进行重定义之前，使用alias就可以保住原来的定义。也可以把它当作Kernel的特殊方法来进行调用。
5.12 何谓破环性的方法？</p>

<p>就是能修改对象内容的方法，常见于字符串、数组或哈希表中。一般是这样的：存在两个同名的方法，一个会拷贝原对象并返回副本；一个会直接修改原对象的内容，并返回修改后的对象。通常后者的方法名后面带有！，它就是破坏性的方法。但是有些不带！的方法也是具有破环性的，如String#concat等等。
5.13 那些情况下会产生副作用？</p>

<p>若在方法中对实参对象使用了破环性的方法的时候，就会产生副作用。</p>

<p>def foo(str)
str.sub!(/foo/, &ldquo;baz&rdquo;)
end</p>

<p>obj = &ldquo;foo&rdquo;
foo(obj)
print obj</p>

<h1>=&gt; &ldquo;baz&rdquo;</h1>

<p>此时，参数对象的内容被修改。另一方面，如果在程序中确有必要的话，也会对某对象发送具有副作用的消息，那就另当别论了。
5.14 能让方法返回<span>多个值</span>吗？</p>

<p>在Ruby中确实只能指定一个方法返回值，但若使用数组的话，就可以返回多个值了。</p>

<p>return 1, 2, 3</p>

<p>上例中，传给return的列表会被当作数组处理。这与下面的代码可谓是异曲同工。</p>

<p>return [1, 2, 3]</p>

<p>另外，若使用多重赋值的话，则可以达到返回多个值的效果。例如</p>

<p>def foo
return 20, 4, 17
end</p>

<p>a, b, c = foo
print &ldquo;a:&rdquo;, a, &ldquo;\n&rdquo; #=&gt; a:20
print &ldquo;b:&rdquo;, b, &ldquo;\n&rdquo; #=&gt; b:4
print &ldquo;c:&rdquo;, c, &ldquo;\n&rdquo; #=&gt; c:17</p>

<p>您也可以这样处理。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Francis Jiang</span></span>

      








  


<time datetime="2012-03-01T00:07:00+08:00" pubdate data-updated="true">Mar 1<span>st</span>, 2012</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/ruby/'>ruby</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://jhjguxin.github.io/blog/2012/03/01/rubycan-kao-shou-ce-vii/" data-via="jhjguxin" data-counturl="http://jhjguxin.github.io/blog/2012/03/01/rubycan-kao-shou-ce-vii/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="medium"></div>
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2012/02/26/rspec-best-practices-and-tips/" title="Previous Post: RSpec best practices and tips">&laquo; RSpec best practices and tips</a>
      
      
        <a class="basic-alignment right" href="/blog/2012/03/02/ruby-loop/" title="Next Post: Ruby-------- loop ">Ruby-------- loop  &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/10/08/tong-guo-mongodumphe-mongorestoreshi-xian-mongodbbei-fen-he-hui-fu-by-chenzhou123520/">通过mongodump和mongorestore实现Mongodb备份和恢复 --by Chenzhou123520</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/10/06/ruby-on-rails-4-dot-0-release-notes/">Ruby on Rails 4.0 Release Notes</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/10/06/rails-active-record-named-scopes/">Rails Active Record Named Scopes</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/09/27/shai-shai-wo-men-de-kai-yuan-xiang-mu-iteyekai-yuan-dai-ma/">晒晒我们的开源项目 ITEYE开源代码</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/09/26/single-sign-on-dan-dian-deng-lu-sso/">Single Sign-on 单点登录 Sso</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/jhjguxin">@jhjguxin</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'jhjguxin',
            count: 10,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Francis Jiang -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
