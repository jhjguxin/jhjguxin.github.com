<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | Francis's Octopress Blog]]></title>
  <link href="http://jhjguxin.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://jhjguxin.github.io/"/>
  <updated>2013-11-12T19:23:30+08:00</updated>
  <id>http://jhjguxin.github.io/</id>
  <author>
    <name><![CDATA[Francis Jiang]]></name>
    <email><![CDATA[864248765@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[解决Illegal mix of collations (latin1_swedish_ci,IMPLICIT) and (utf8_general_ci,COER]]></title>
    <link href="http://jhjguxin.github.io/blog/2012/06/13/jie-jue-illegal-mix-of-collations-latin1-swedish-ci-implicit-and-utf8-general-ci-coer/"/>
    <updated>2012-06-13T10:56:00+08:00</updated>
    <id>http://jhjguxin.github.io/blog/2012/06/13/jie-jue-illegal-mix-of-collations-latin1-swedish-ci-implicit-and-utf8-general-ci-coer</id>
    <content type="html"><![CDATA[<h2>解决Illegal mix of collations (latin1_swedish_ci,IMPLICIT) and (utf8_general_ci,COER</h2>

<p>部署完项目，测试一下，诶，数据出来了 没有多大问题（暗舒一口气）。继续测吧，一点新建完了，报错了，看看什么错误</p>

<p>一看完了 java.sql.SQLException: Illegal mix of collations (latin1_swedish_ci,IMPLICIT)</p>

<p>and (utf8_general_ci,COERCIBLE) for operation &lsquo;=&rsquo; 是这个错误 ，什么原因呢，第一次遇到。</p>

<p>头大了。去查文档说是：结果集中有两种字符集。 我晕了 ，怎么会这样呢，看看表结构，一种啊。 继续查吧。</p>

<table width="620" border="0" cellspacing="1" cellpadding="1" align="center">
<tbody>
<tr>
<td bgcolor="#FFE7CE" width="464" height="27"> 代码如下</td>
<td align="center" bgcolor="#FFE7CE" width="109">复制代码</td>
</tr>
<tr>
<td id="copy7096" colspan="2" valign="top" bgcolor="#FFFFFF" height="auto">SHOW VARIABLES LIKE 'character_set_%'; 查看一下 显示+--------------------------+----------------------------+

| Variable_name | Value |

+--------------------------+----------------------------+

| character_set_client | utf8|

| character_set_connection | utf8|

| character_set_database | latin1 |

| character_set_results | utf8|

| character_set_server | latin1 |

| character_set_system | utf8 |

| character_sets_dir | /home/jh/<a href="http://www.111cn.net/list-110/" target="_blank">mysql</a>/share/mysql/charsets |</td>
</tr>
</tbody>
</table>


<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>再用 SHOW VARIABLES LIKE &lsquo;collation_%&rsquo;; 查看一下 显示</p>

<table width="620" border="0" cellspacing="1" cellpadding="1" align="center">
<tbody>
<tr>
<td bgcolor="#FFE7CE" width="464" height="27"> 代码如下</td>
<td align="center" bgcolor="#FFE7CE" width="109">复制代码</td>
</tr>
<tr>
<td id="copy1112" colspan="2" valign="top" bgcolor="#FFFFFF" height="auto">+----------------------+-------------------+| Variable_name | Value |

+----------------------+-------------------+

| collation_connection | utf8_swedish_ci |

| collation_database | latin1_swedish_ci |

| collation_server | latin1_swedish_ci |

+----------------------+-------------------+</td>
</tr>
</tbody>
</table>


<p>原来如此啊 哈哈 知道错在哪里 剩下的就好办了</p>

<p><strong>解决方法：</strong></p>

<p>依次执行：</p>

<table width="620" border="0" cellspacing="1" cellpadding="1" align="center">
<tbody>
<tr>
<td bgcolor="#FFE7CE" width="464" height="27"> 代码如下</td>
<td align="center" bgcolor="#FFE7CE" width="109">复制代码</td>
</tr>
<tr>
<td id="copy2457" colspan="2" valign="top" bgcolor="#FFFFFF" height="auto">set character_set_database =utf8;

&nbsp;

set character_set_results =utf8;

&nbsp;

set character_set_server =utf8;

&nbsp;

set character_set_system =utf8; --此处utf-8也可以

&nbsp;

然后执行：

&nbsp;

SET collation_server = utf8_general_ci

&nbsp;

&nbsp;

SET collation_database = utf8_general_ci</td>
</tr>
</tbody>
</table>


<p>执行完之后，请检查mysql下每个<a href="http://www.111cn.net/database/database.html" target="_blank">数据库</a>，表，字段是否都是utf8，不是则改过来，这样子就不会出现</p>

<p>&nbsp;</p>

<p>最笨的方法是重装一下数据库。（一般不要用这种方法呀）</p>

<p>最终解决方法：</p>

<p>1.1 如果是windows版本的mysql，那么在安装的时候，系统就会提示用哪种编码。</p>

<p>如果安装的时候设置错误了，修改mysql安装目录下的my.ini文件：</p>

<table width="620" border="0" cellspacing="1" cellpadding="1" align="center">
<tbody>
<tr>
<td bgcolor="#FFE7CE" width="464" height="27"> 代码如下</td>
<td align="center" bgcolor="#FFE7CE" width="109">复制代码</td>
</tr>
<tr>
<td id="copy1531" colspan="2" valign="top" bgcolor="#FFFFFF" height="auto">[mysql]default-character-set=utf8

...

# The default character set that will be used when a new schema or table is

# created and no character set is defined

default-character-set=utf8</td>
</tr>
</tbody>
</table>


<p>配置好后，重启mysql。</p>

<p>1.2 如果是linux版本的mysql</p>

<p>&nbsp;</p>

<p>修改mysql的配置文件,使数据库与服务器操作系统的字符集设置一致。</p>

<p>vi /etc/my.cnf 设置(如果没有发现这个文件，就新建1个)</p>

<table width="620" border="0" cellspacing="1" cellpadding="1" align="center">
<tbody>
<tr>
<td bgcolor="#FFE7CE" width="464" height="27"> 代码如下</td>
<td align="center" bgcolor="#FFE7CE" width="109">复制代码</td>
</tr>
<tr>
<td id="copy7728" colspan="2" valign="top" bgcolor="#FFFFFF" height="auto">[mysqld]datadir=/var/lib/mysql

socket=/var/lib/mysql/mysql.sock

default-character-set=utf8</td>
</tr>
</tbody>
</table>


<p>(增加的关键一句,使得数据库缺省以utf8存储)</p>

<p>当然，修改后，要重启数据库。（这样设置后对新建的数据库表才起作用）</p>

<p>&nbsp;</p>

<table width="620" border="0" cellspacing="1" cellpadding="1" align="center">
<tbody>
<tr>
<td bgcolor="#FFE7CE" width="464" height="27"> 代码如下</td>
<td align="center" bgcolor="#FFE7CE" width="109">复制代码</td>
</tr>
<tr>
<td id="copy8374" colspan="2" valign="top" bgcolor="#FFFFFF" height="auto">用SHOW VARIABLES LIKE 'character_set_%';命令查看到如下内容：+--------------------------+-----------------------------------------------------------------------+

| Variable_name | Value |

+--------------------------+-----------------------------------------------------------------------+

| character_set_client | utf8|

| character_set_connection | utf8|

| |character_set_database |utf8 |

| character_set_filesystem | binary |

| character_set_results | utf8|

| character_set_server | utf8 |

| character_set_system | utf8 |

| character_sets_dir | /home/jh/mysql/share/mysql/charsets |

+--------------------------+-----------------------------------------------------------------------+</td>
</tr>
</tbody>
</table>


<p>发现关键项目已经用了utf8，但这样还不够，还要保证客户端也是用utf8的字符集来操作的。</p>

<p>登录的时候，要用以下命令：mysql &mdash;default-character-set=utf8 -u root -p</p>

<p>再次用SHOW VARIABLES LIKE &lsquo;character_set_%&rsquo;;命令查看，结果变成了：</p>

<table width="620" border="0" cellspacing="1" cellpadding="1" align="center">
<tbody>
<tr>
<td bgcolor="#FFE7CE" width="464" height="27"> 代码如下</td>
<td align="center" bgcolor="#FFE7CE" width="109">复制代码</td>
</tr>
<tr>
<td id="copy4025" colspan="2" valign="top" bgcolor="#FFFFFF" height="auto">+--------------------------+-----------------------------------------------------------------------+| Variable_name | Value |

+--------------------------+-----------------------------------------------------------------------+

| character_set_client | utf8 |

| character_set_connection | utf8 |

| character_set_database | utf8 |

| character_set_filesystem | binary |

| character_set_results | utf8 |

| character_set_server | utf8 |

| character_set_system | utf8 |

| character_sets_dir | /home/jh/mysql/share/mysql/charsets/ |</td>
</tr>
</tbody>
</table>


<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</p>

<p>这样才能保证客户端所发命令都是基于utf8格式的，比如说建立数据库和表，默认就会以utf8编码，而无须再次指定。（再次说一句对新建的数据库和表起作用）。</p>

<p>另外：</p>

<p>第三种方法：网上看到的，先记录一下。</p>

<p>1.如果安装mysql的编码已不能更改,很多朋友是购买虚拟主机建立网站,无权更改MYSQL的安装编码,这一关我们可以跳过,因为只要后面的步聚正确,一样能解决乱码问题
2.修改数据库编码，如果是数据库编码不正确: 可以在<a href="http://www.111cn.net/phper/php.html" target="_blank">php</a>myadmin 执行如下命令: ALTER DATABASE <code>test</code> DEFAULT CHARACTER SET utf8 COLLATE utf8_bin
以上命令就是将test数据库的编码设为utf8
3.修改表的编码：</p>

<table width="620" border="0" cellspacing="1" cellpadding="1" align="center">
<tbody>
<tr>
<td bgcolor="#FFE7CE" width="464" height="27"> 代码如下</td>
<td align="center" bgcolor="#FFE7CE" width="109">复制代码</td>
</tr>
<tr>
<td id="copy1726" colspan="2" valign="top" bgcolor="#FFFFFF" height="auto">ALTER TABLE `category` DEFAULT CHARACTER SET utf8 COLLATE utf8_bin</td>
</tr>
</tbody>
</table>


<p>以上命令就是将一个表category的编码改为utf8
4.修改字段的编码：</p>

<table width="620" border="0" cellspacing="1" cellpadding="1" align="center">
<tbody>
<tr>
<td bgcolor="#FFE7CE" width="464" height="27"> 代码如下</td>
<td align="center" bgcolor="#FFE7CE" width="109">复制代码</td>
</tr>
<tr>
<td id="copy2640" colspan="2" valign="top" bgcolor="#FFFFFF" height="auto">
<pre>mysql&gt; use askjane_development;
Database changed
mysql&gt; alter database mydb character set utf8;
ERROR 1 (HY000): Can't create/write to file './mydb/db.opt' (Errcode: 2)
mysql&gt; ALTER TABLE tags CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci;Query OK, 2 rows affected (0.35 sec)</pre>
</td>
</tr>
</tbody>
</table>


<p>以上命令就是将test表中 dd的字段编码改为utf8
5.如果是这种情况容易解决，只需检查下页面，修改源文件的charset即可
, //这个正确就无问题了
6.这种情况也是修改页面charset即可.</p>

<p>&nbsp;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Logs Are Streams, Not Files]]></title>
    <link href="http://jhjguxin.github.io/blog/2012/06/07/logs-are-streams-not-files/"/>
    <updated>2012-06-07T21:55:00+08:00</updated>
    <id>http://jhjguxin.github.io/blog/2012/06/07/logs-are-streams-not-files</id>
    <content type="html"><![CDATA[<h2>Logs Are Streams, Not Files</h2>

<p>Server daemons (such as PostgreSQL or Nginx) and applications (such as a Rails or Django app) sometimes offer a configuration parameter for a path to the program’s logfile. This can lead us to think of logs as files.</p>

<p>But a better conceptual model is to treat logs as time-ordered streams: there is no beginning or end, but rather an ongoing, collated collection of events which we may wish to view in realtime as they happen (e.g. via <code>tail -f</code> or <code>heroku logs &mdash;tail</code>) or which we may wish to search in some time window (e.g. via <code>grep</code> or Splunk).</p>

<h2>Using the power of unix for logs</h2>


<p>Unix provides some excellent tools for handling streams. There are two default output streams, <code>stdout</code> and<code>stderr</code>, available automatically to all programs. Streams can be turned into files with a redirect operator, but they can also be channeled in more powerful ways, such as splitting the streams to multiple locations or pipelining the stream to another program for further processing.</p>

<p>A program that uses <code>stdout</code> for its logging can easily log to any file you wish:</p>

<pre><code>$ mydaemon &gt;&gt; /var/log/mydaemon.log</code></pre>


<p>(Typically you would not invoke this command directly, but would run this from an init program such as Upstart or Systemd.)</p>

<p>Programs that send their logs directly to a logfile lose all the power and flexibility of unix streams. What’s worse is that they end up reinventing some of these capabilities, badly. How many programs end up re-writing log rotation, for example?</p>

<h2>Distributed logging with syslog</h2>


<p>Logging on any reasonably large distributed system will generally end up using the syslog protocol to send logs from many components to a single location. Programs that treat logs as files are now on the wrong path: if they wisht to log to syslog, each program needs to implement syslog internally &ndash; and provide yet more logging configuration options to set the various syslog fields.</p>

<p>A program using <code>stdout</code> for logging can use syslog without needing to implement any syslog awareness into the program, by piping to the standard <code>logger</code> command available on all modern unixes:</p>

<pre><code>$ mydaemon | logger</code></pre>


<p>Perhaps we want to split the stream and log to a local file as well as syslog:</p>

<pre><code>$ mydaemon | tee /var/log/mydaemon.log | logger</code></pre>


<p>A program which uses <code>stdout</code> is equipped to log in a variety of ways without adding any weight to its codebase or configuration format.</p>

<h2>Other distributed logging protocols</h2>


<p>Syslog is an entrenched standard for distributed logging, but there are other, more modern options as well.<a href="http://www.splunk.com/">Splunk</a>, fast becoming a indispensable tool for anyone running a large software service, can accept syslog; but it also has its own custom protocol which offers additional features like authentication and encryption.<a href="https://github.com/facebook/scribe/wiki">Scribe</a> is another example of a modern logging protocol.</p>

<p>Programs that log to <code>stdout</code> can be adapted to work with a new protocol without needing to modify the program. Simply pipe the program’s output to a receiving daemon just as you would with the <code>logger</code> program for syslog. Treating your logs as streams is a form of <a href="http://en.wikipedia.org/wiki/Future_proof">future-proofing</a> for your application.</p>

<h2>Logging in the Ruby world</h2>


<p>Most Rack frameworks (Sinatra, Ramaze, etc) and Rack webservers (Mongrel, Thin, etc) do the right thing: they log to <code>stdout</code>. If you run them in the foreground, as is typical of development mode, you see the output right in your terminal. This is exactly what you want. If you run in production mode, you can redirect the output to a file, to syslog, to both, or to any other logging system that can accept an input stream.</p>

<p>Unfortunately, Rails stands out as a major exception to this simple principle. It creates its own log directory and writes various files into it; some plugins even take it upon themselves to write their own, separate logfiles. This hurts the local development experience: what you see in your terminal isn’t complete, so you have to open a separate window with <code>tail -f log/*.log</code> to get the information you want. But it hurts the deployment experience even more, because you end up having to tinker around with a bunch of Rails logger configuration options to get your logs from all your web machines to merge into a single stream.</p>

<h2>Logging on Heroku</h2>


<p>The need to treat application logs as a stream is especially poignant with <a href="http://blog.heroku.com/archives/2010/12/13/logging/">Heroku&rsquo;s new logging system</a>. On the backend, we route logs with a syslog router written in Erlang called <a href="https://github.com/heroku/logplex">Logplex</a>.</p>

<p>Logplex handles input streams (which we call “sinks”) from many different sources: all the dynos running on the app, system components like our HTTP router, and (currently in alpha) logs from add-on providers. Sinks are merged together into channels (each app has its own channel) which is a unified stream of all logs relevant to the app. This allows developers to see a holistic view of everything happening with their app, or to filter down to logs from a particular type of sink (for example: just logs from the HTTP router, or just logs from worker processes).</p>

<p>Further, log streams can also be sent outbound, which we call “drains.” Users can configure syslog drains, and we’re currently working up a technical design for how add-on providers can automatically add drains. This latter item will enable a new class of log search and archival add-on, most notably the emerging syslog-as-a-service products like <a href="http://www.loggly.com/">Loggly</a> and <a href="https://papertrailapp.com/">Papertrail</a>.</p>

<p>This logging system works quite well, and it gets even better with the new features on the way &ndash; but it only works where all programs output their logs as streams. Programs that write logfiles, such as Rails in its default configuration, don’t make sense in this world.</p>

<p>As a workaround, Heroku injects the <a href="https://github.com/ddollar/rails_log_stdout/blob/master/init.rb">rails_log_stdout</a> plugin into Rails apps at deploy time. We’d prefer not to have to do this (injecting code is a dicey way to solve problems), but it’s the best way to get Rails logs into the app’s logstream without requiring extra configuration from the app developer.</p>

<h2>Conclusion</h2>


<p>Logs are a stream, and it behooves everyone to treat them as such. Your programs should log to <code>stdout</code>and/or <code>stderr</code> and omit any attempt to handle log paths, log rotation, or sending logs over the syslog protocol. Directing where the program’s log stream goes can be left up to the runtime container: a local terminal or IDE (in development environments), an Upstart / Systemd launch script (in traditional hosting environments), or a system like Logplex/Heroku (in a platform environment).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LVM (简体中文)]]></title>
    <link href="http://jhjguxin.github.io/blog/2012/06/01/lvm-jian-ti-zhong-wen/"/>
    <updated>2012-06-01T10:55:00+08:00</updated>
    <id>http://jhjguxin.github.io/blog/2012/06/01/lvm-jian-ti-zhong-wen</id>
    <content type="html"><![CDATA[<h2>LVM (简体中文)</h2>

<h2> 介绍</h2>


<p>LVM 是一个应用于 Linux 内核的本地卷管理器 (Logical Volume Manager)。 使用 LVM 你可以抽象你的存储空间，并且可以有很容易更改的“虚拟分区”。LVM的基本模块如下：</p>

<ul>
    <li><strong>Physical volume (PV)</strong>: 物理卷,例如一个硬盘,或一个Software RAID设备; 硬盘的一个分区 (或者甚至硬盘本身或者回环文件)，在它上面可以建立卷组。It has a special header and is divided into physical extents. Think of physical volumes as big building blocks which can be used to build your hard drive.</li>
    <li><strong>Volume group (VG)</strong>: 卷组,将一组物理卷收集为一个管理单元;Group of physical volumes that are used as storage volume (as one disk). They contain logical volumes. Think of volume groups as hard drives.</li>
    <li><strong>Logical volume(LV)</strong>: 逻辑卷,等同于传统分区,可看作便准的块设备,以容纳文件系统;A "virtual/logical partition" that resides in a volume group and is composed of physical extents. Think of logical volumes as normal partitions.</li>
    <li><strong>Physical extent (PE)</strong>: 物理块,划分物理卷的数据块;A small part of a disk (usually 4MB) that can be assigned to a logical Volume. Think of physical extents as parts of disks that can be allocated to any partition.</li>
</ul>


<p>使用 LVM 你可以比正常的硬盘分区更容易的管理硬盘分区（逻辑卷）。例如，你可以：</p>

<ul>
    <li>使用卷组(VG)，使众多硬盘空间看起来像一个大硬盘。</li>
    <li>使用逻辑卷（LV），可以创建跨越众多硬盘空间的分区。</li>
    <li>可以根据需要，对分区（LV）和硬盘空间（VG）进行创建、删除、调整大小等操作。(it doesn't depend on position of the logical volumes within volume groups as with normal partitions)</li>
    <li>Resize/create/delete partitions(LV) and disks(VG) <em>online</em> (filesystems on them still need to be resized, but some support online resizing)</li>
    <li><em>Name</em> your disks(VG) and partitions(LV) as you like</li>
    <li>Create small partitions(LV) and resize them "<em>dynamically</em>" as they get more filled (growing must be still done by hand, but you can do it online with some filesystems)</li>
    <li>...</li>
</ul>


<p>示例:</p>

<pre><strong>两块物理硬盘</strong>

  硬盘1 (/dev/sda):
     _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    |分区1 50GB (Physical volume) |分区2 80GB (Physical volume)     |
    |/dev/sda1                   |/dev/sda2                       |
    |_ _ _ _ _ _ _ _ _ _ _ _ _ _ |_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ |

  硬盘2 (/dev/sdb):
     _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    |分区1 120GB (Physical volume)                 |
    |/dev/sdb1                                    |
    | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ __ _ _|</pre>


<pre><strong>LVM方式</strong>

  卷组VG1 (/dev/MyStorage/ = /dev/sda1 + /dev/sda2 + /dev/sdb1):
     _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  
    |逻辑卷lv1 15GB         |逻辑卷lv2 35GB              |逻辑卷lv3 200GB               |
    |/dev/MyStorage/rootvol|/dev/MyStorage/usrvol     |/dev/MyStorage/homevol       |
    |_ _ _ _ _ _ _ _ _ _ _ |_ _ _ _ _ _ _ _ _ _ _ _ _ |_ _ _ _ _ _ _ _ _ _ _ _ _ _ _|</pre>


<p>总而言之: With LVM you can use all your storage space as one big disk (volume group) and have more flexibility over your partitions (logical volumes).</p>

<h2>Advantages</h2>


<p>Here are some things you can do with LVM that you can&rsquo;t (or can&rsquo;t do easily) with just mdadm, MBR partitions, GPT partitions, parted/gparted and a file-level tool like rsync.</p>

<ol>
    <li>Online/live partition resizing</li>
    <li>No need for an extended partition (not relevant for GPT)</li>
    <li>Resize partitions regardless of their order on disk (no need to ensure surrounding available space)</li>
    <li>Online/live migration of partitions being used by services without having to restart services</li>
</ol>


<p>These can be very helpful in a server situation, desktop less so, but you must decide if the features are worth the abstraction.</p>

<h2>安装</h2>


<p>在做其他工作之前，我们需要加载合适的模块：</p>

<pre># modprobe dm-mod</pre>


<p>如果你已经安装好了操作系统，并只是想利用增加或尝试一个LVM分区，请跳到这 <a title="Lvm" href="https://wiki.archlinux.org/index.php/Lvm#Partition_disks">partition disks</a>.</p>

<h3>在 LVM 上安装 Arch Linux</h3>


<p>在开始安装arch之前（即输入：/arch/setup之前），先使用cfdisk等工具来规划分区。因为grub不能从LVM逻辑卷引导启动 （版本1.0时），所以需要先创建一个/boot引导区，100MB应该够了。另外的解决办法就是使用lilo或者高于1.95版本的grub。</p>

<h3>创建 LVM 分区</h3>


<p>接下来，要创建LVM将使用的分区。文件类型使用'Linux LVM'，所以使用分区id 0x8e (文件系统类型：8E)。在需要使用LVM的每块硬盘上，各创建一个LVM分区。 Your logical volumes will reside inside these partitions so size them accordingly. If you will use only LVM and no other external partitions, use all of free space on each disk.</p>

<div><strong> 警告: </strong> /boot不能包含在LVM分区里，因为grub (version&lt;1.95)不能从LVM中引导grub。</div>


<div><strong> 小贴士: </strong>所有硬盘的所有LVM分区可以被设置成看起来就像一个大硬盘。</div>


<h3>创建物理卷（PV）</h3>


<p>接下来，要加载使用lvm所需的相应模块:</p>

<pre># modprobe dm-mod</pre>


<p>用命令'fdisk -l'查看那个分区的文件系统类型是'Linux LVM'，然后在其上创建一个物理卷组pv（假设是/dev/sda2)，输入如下命令:</p>

<pre># pvcreate /dev/sda2</pre>


<p>Substitute /dev/sda2 with all your partitions to create physical volumes on all of them. This command creates a header on each partition so it can be used for LVM. 查看物理卷情况：</p>

<pre># pvdisplay</pre>


<h3>创建卷组（VG）</h3>


<p>创建完成物理卷之后，就是开始创建卷组了。 如果有两个以上的物理卷pv（比如下面例子，有两个/dev/sda2和/dev/sdb1），首先必须先在其中一个创建一个卷组vg，然后让该卷组vg 扩大到其他所有的物理卷pv（这里假设你只使用一个卷组vg来管理其他所有的物理卷pv。）:</p>

<pre># vgcreate VolGroup00 /dev/sda2
# vgextend VolGroup00 /dev/sdb1</pre>


<p>其中，“VolGroup00”名字换成你自己起的名字即可。接下来看看卷组情况：</p>

<pre># vgdisplay</pre>


<div><strong> 注意: </strong>可以创建多于一个的卷组，但因此将让你的硬盘空间看起来不像一块硬盘。</div>


<h3>创建逻辑卷（LV）</h3>


<p>创建完卷组vg之后，就可以开始创建逻辑卷了。输入下面命令：</p>

<pre># lvcreate -L 10G VolGroup00 -n lvolhome</pre>


<p>其中10G是大小，VolGroup00是卷组vg名称，lvolhome是逻辑卷lv名称，这些都可以根据你自己喜欢设定，以后可以使用/dev/mapper/Volgroup00-lvolhome 或者 /dev/VolGroup00/lvolhome来操作.</p>

<p>查看逻辑卷情况:</p>

<pre># lvdisplay</pre>


<div><strong> 注意: </strong>You may need to load the <em>device-mapper</em> kernel module (<strong>modprobe dm-mod</strong>) for the above commands to succeed.</div>


<div><strong> 小贴士: </strong>一开始可以创建小一点的逻辑卷lv，然后留一部分未使用空间在卷组vg里，以后可以根据需要再扩展各个逻辑卷。</div>


<h3>建立文件系统与挂载逻辑卷</h3>


<p>Your logical volumes should now be located in <strong>/dev/mapper/</strong> and <strong>/dev/YourVolumeGroupName</strong>. If you can&rsquo;t find them use the next commands to bring up the module for creating device nodes and to make volume groups availabile:</p>

<pre># modprobe dm-mod
# vgscan
# vgchange -ay</pre>


<p>Now you can create filesystems on logical volumes and mount them as normal partitions (if you are installing Arch linux, skip this step):</p>

<pre># mkfs.ext3 /dev/mapper/VolGroup00-lvolhome
# mount /dev/mapper/VolGroup00-lvolhome /home</pre>


<p>如果你正在安装Archlinux，到 <em>Prepare Hard Drive</em> 这一步时，转到第三项 <em>Set Filesystem Mountpoints</em> ，请 <em><strong>在进入安装前，阅读下面的 <a title="Arch LVM配置 (简体中文)" href="https://wiki.archlinux.org/index.php/Arch_LVM%E9%85%8D%E7%BD%AE_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#.E9.87.8D.E8.A6.81">重要</a>部分 !</strong></em></p>

<h3>重要</h3>


<p>有几点在使用/安装带有 LVM 的 Arch Linux 时你需要特别注意的地方。（括号里是相关的安装过程中的菜单）：</p>

<h4>设置文件系统挂载点</h4>


<ul>
    <li>当选择挂载点时（除了/boot），千万不要选择实际存在的逻辑卷（比如：<code>/dev/sda2</code>），只需选择由lv创建的逻辑卷（比如: <code>/dev/mapper/Volgroup00-lvolhome</code>)。</li>
</ul>


<h4>配置系统</h4>


<ul>
    <li>确保在 <code>/etc/rc.conf</code> 中，把<code>USELVM="no"</code>修改成 <code>USELVM="yes"</code>。<code>rc.sysinit</code> 脚本处理 <code>USELVM</code> 变量时只会识别<code>yes</code> 或者 <code>YES</code>，不支持大小写混合。</li>
</ul>


<ul>
    <li>确保 <em>lvm2</em> 在 <code>/etc/mkinitcpio.conf</code> HOOKS 部分的 <em>filesystems</em> 前面，这样您的内核就可以在启动时找到 LVM 卷。</li>
    <li>If your root filesystem ( "/" ) is put onto a logical volume, make sure regenerate kernel image based on above modified <code>/etc/mkinitcpio.conf</code> by using below command so that bootloader can find your root during booting</li>
</ul>


<pre>     cd /boot 
     mkinitcpio -p linux</pre>


<ul>
    <li>确保为 root 使用了正确的卷。</li>
</ul>


<dl><dd>对于 GRUB，编辑<code>/boot/grub/menu.lst</code> ：</dd></dl>


<pre>     ...
     (0) Arch Linux
     title  Arch Linux
     root   (hd0,0)
     kernel /vmlinuz-linux <strong>root=/dev/mapper/VolGroup00-lvolroot</strong> resume=/dev/mapper/VolGroup00-lvolswap ro
     initrd /initramfs-linux.img
     ...</pre>


<dl><dd>For SYSLINUX, edit <code>/boot/syslinux/syslinux.cfg</code>:</dd></dl>


<pre>     ...
     # (0) Arch Linux
     LABEL arch
       MENU LABEL Arch Linux
       LINUX ../vmlinuz-linux
       APPEND <strong>root=/dev/mapper/VolGroup00-lvolroot</strong> ro
       INITRD ../initramfs-linux.img</pre>


<dl><dd>对于 LILO ，检查 <code>/etc/lilo.conf</code>:</dd></dl>


<pre>     ...
     image=/boot/vmlinuz-linux
       label=arch
       append="<strong>root=/dev/mapper/VolGroup00-lvolroot</strong> resume=/dev/mapper/VolGroup00-lvolswap ro"
       initrd=/boot/initramfs-linux.img
     ...</pre>


<h2>配置</h2>


<h3>扩大逻辑卷</h3>


<p>To grow a logical volume you first need to grow the logical volume and then the filesystem to use the newly created free space. Let&rsquo;s say we have a logical volume of 15GB with ext3 on it and we want to grow it to 20G. We need to do the following steps:</p>

<pre># lvextend -L 20G VolGroup00/lvolhome (or lvresize -L +5G VolGroup00/lvolhome)
# resize2fs /dev/VolGroup00/lvolhome</pre>


<p>You may use lvresize insted of lvextend.</p>

<p>If you want to fill all the free space on a volume group use the next command:</p>

<pre># lvextend -l +100%FREE VolGroup00/lvolhome</pre>


<div><strong> 警告: </strong>并非所有的文件系统都支持无损或在线扩大逻辑卷。</div>


<div><strong> 注意: </strong>If you do not resize your filesystem, you will still have a volume with the same size as before (volume will be bigger but partly unused).</div>


<h3>缩小逻辑卷</h3>


<p>Because your filesystem is probably as big as the logical volume it resides on, you need to shrink the filesystem first and then shrink the logical volume. Depending on your filesystem, you may need to unmount it first. Let us say we have a logical volume of 15GB with ext3 on it and we want to shrink it to 10G. We need to do the following steps:</p>

<pre># resize2fs /dev/VolGroup00/lvolhome 9G
# lvreduce -L 10G VolGroup00/lvolhome (or lvresize -L -5G VolGroup00/lvolhome)
# resize2fs /dev/VolGroup00/lvolhome</pre>


<p>Here we shrunk the filesystem more than needed so that when we shrunk the logical volume we did not accidentally cut off the end of the filesystem. After that we normally grow the filesystem to fill all free space left on logical volume. You may use <code>lvresize</code> instead of <code>lvreduce</code>.</p>

<div><strong> Warning: </strong>
<ul>
    <li>Do not reduce the filesystem size to less than the amount of space occupied by data or you risk data loss.</li>
    <li>Not all filesystems support shrinking without loss of data and/or shrinking online.</li>
</ul>
</div>


<div><strong> Note: </strong>It is better to reduce the filesystem to a smaller size than the logical volume, so that after resizing the logical volume, we do not accidentally cut off some data from the end of the filesystem.</div>


<h3>Remove logical volume</h3>


<div><strong> Warning: </strong>Before you remove a logical volume, make sure to move all data that you want to keep somewhere else, otherwise it will be lost!</div>


<p>First, find out the name of the logical volume you want to remove. You can get a list of all logical volumes installed on the system with:</p>

<pre># lvs</pre>


<p>Next, look up the mountpoint for your chosen logical volume&hellip;:</p>

<pre>$ df -h</pre>


<p>&hellip; and unmount it:</p>

<pre># umount /your_mountpoint</pre>


<p>Finally, remove the logical volume:</p>

<pre># lvremove /dev/yourVG/yourLV</pre>


<p>Confirm by typing &ldquo;y&rdquo; and you are done.</p>

<p>Dont forget, to update /etc/fstab:</p>

<pre># sudo nano /etc/fstab</pre>


<p>You can verify the removal of your logical volume by typing &ldquo;lvs&rdquo; as root again (see first step of this section).</p>

<h3>添加分区到卷组中</h3>


<p>To add a partition to your volume group you must first make its type &lsquo;Linux LVM&rsquo; (for example with <code>cfdisk</code>). Then you need to create a physical volume on it and extend the volume group over it:</p>

<pre># pvcreate /dev/sdb1
# vgextend VolGroup00 /dev/sdb1</pre>


<p>Now you have free space in your volume group that can be used by logical volumes in this group.</p>

<div><strong> Tip: </strong>You can add partitions from any disks to volume groups.</div>


<h3>从卷组中移除卷</h3>


<p>All of the data on that partition needs to be moved to another partition. Fortunately, LVM makes this easy:</p>

<pre># pvmove /dev/sdb1</pre>


<p>If you want to have the data on a specific physical volume, specify that as the second argument to <code>pvmove</code>:</p>

<pre># pvmove /dev/sdb1 /dev/sdf1</pre>


<p>Then the physical volume needs to be removed from the volume group:</p>

<pre># vgreduce myVg /dev/sdb1</pre>


<p>Or remove all empty physical volumes:</p>

<pre># vgreduce --all vg0</pre>


<p>And lastly, if you want to use the partition for something else, and want to avoid LVM thinking that the partition is a physical volume:</p>

<pre># pvremove /dev/sdb1</pre>


<h3>快照功能</h3>


<h4>介绍</h4>


<p>LVM可以给系统创建一个快照，由于使用了COW (copy-on-write) 策略，相比传统的备份更有效率。 The initial snapshot you take simply contains hard-links to the inodes of your actual data. So long as your data remains unchanged, the snapshot merely contains its inode pointers and not the data itself. Whenever you modify a file or directory that the snapshot points to, LVM automatically clones the data, the old copy referenced by the snapshot, and the new copy referenced by your active system. 这样的话，如果你只修改了不超过2G数据（包括原始的和快照的），你将可以只使用2G的空间，就能快照一个有35G的数据的系统。</p>

<h4>配置</h4>


<p>You create snapshot logical volumes just like normal ones.</p>

<pre># lvcreate --size 100M --snapshot --name snap01 /dev/mapper/vg0-pv</pre>


<p>With that volume, you may modify less than 100M of data, before the snapshot volume fills up.</p>

<p>Todo: scripts to automate snapshots of root before updates, to rollback&hellip; updating menu.lst to boot snapshots (separate article?)</p>

<p>snapshots are primarily used to provide a frozen copy of a filesystem to make backups; a backup taking two hours provides a more consistent image of the filesystem than directly backing up the partition.</p>

<h2>常见问题</h2>


<h3>LVM 命令不起作用</h3>


<p>try preceeding commands with <em>lvm</em> like this:</p>

<pre># lvm pvdisplay</pre>


<h3>设定文件系统挂载点的页面不显示逻辑卷</h3>


<p>If you are installing on a system where there is an existing volume group, you may find that even after doing &ldquo;modprobe dm-mod&rdquo; you don&rsquo;t see the list of logical volumes.</p>

<p>In this case, you may also need to do:</p>

<pre># vgchange -ay &lt;volgroup&gt;</pre>


<p>in order to activate the volume group and make the logical volumes available.</p>

<h3>Receiving Input/Output Errors after plugging in a removable device with LVM partitions</h3>


<p>Symptoms:</p>

<pre>~$ sudo vgscan
 Reading all physical volumes.  This may take a while...
 /dev/backupdrive1/backup: read failed after 0 of 4096 at 319836585984: Input/output error
 /dev/backupdrive1/backup: read failed after 0 of 4096 at 319836643328: Input/output error
 /dev/backupdrive1/backup: read failed after 0 of 4096 at 0: Input/output error
 /dev/backupdrive1/backup: read failed after 0 of 4096 at 4096: Input/output error
 Found volume group "backupdrive1" using metadata type lvm2
 Found volume group "networkdrive" using metadata type lvm2</pre>


<p>Cause:</p>

<dl><dd>Removing an external LVM drive without deactivating the volume group(s) first. Before you disconnect, make sure to:</dd></dl>


<pre># vgchange -an &lt;volume group name&gt;</pre>


<p>Fix: (assuming you already tried to activate the volume group with vgchange -ay &lt;vg&gt;, and are receiving the Input/output errors</p>

<pre># vgchange -an &lt;volume group name&gt;</pre>


<dl><dd>Unplug the external drive and wait a few minutes</dd></dl>


<pre># vgscan
# vgchange -ay &lt;volume group name&gt;</pre>


<h2>技巧</h2>


<h2>更多资源</h2>


<p>archwiki的其他关于LVM的文章：</p>

<ul>
    <li><a title="Installing with Software RAID or LVM" href="https://wiki.archlinux.org/index.php/Installing_with_Software_RAID_or_LVM">Installing with software RAID or LVM</a></li>
    <li><a title="RAID Encryption LVM" href="https://wiki.archlinux.org/index.php/RAID_Encryption_LVM">RAID encryption LVM</a></li>
</ul>


<p>外部资源：</p>

<ul>
    <li><a href="http://en.wikipedia.org/wiki/Logical_Volume_Manager_%28Linux%29" rel="nofollow">LVM on wikipedia</a></li>
    <li><a href="http://tldp.org/HOWTO/LVM-HOWTO/" rel="nofollow">LVM HOWTO on tldp.org </a></li>
    <li><a href="http://www.gentoo.org/doc/en/lvm2.xml" rel="nofollow">Gentoo LVM2 installation at gentoo.org </a></li>
    <li><a href="http://en.gentoo-wiki.com/wiki/LVM" rel="nofollow">LVM at en.gentoo-wiki.com</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
