
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Francis's Octopress Blog</title>
  <meta name="author" content="Francis Jiang">

  
  <meta name="description" content="No one is coming Happiness: resilience, optimism, self-faith, sence-meaning, social behavior, helping others
Stop blaming others. Take responsibility &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jhjguxin.github.io/blog/page/8">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Francis's Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-25901353-3']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Francis's Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jhjguxin.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/readme">Readme</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/30/no-one-is-coming/">No One Is Coming</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-30T23:36:00+08:00" pubdate data-updated="true">Mar 30<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>No one is coming</h2>

<p>Happiness: resilience, optimism, self-faith, sence-meaning, social behavior, helping others
Stop blaming others. Take responsibility of your life.
No one is coming. You are responsible for your life, for your self-confidence, for your self-esteem, for your happiness.
No one is coming. It&rsquo;s up to you to make the most out of this experience.
People are comfortably numb.
Clutivating personal growth, working on the positive.
Idealism and good intentions are not enough to resolve conflict.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/30/ruby-style-guide-dot-en-dot-md/">ruby-style-guide.en.md</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-30T12:56:00+08:00" pubdate data-updated="true">Mar 30<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>ruby-style-guide.en.md</h2>

<h1>Prelude</h1>


<blockquote>Style is what separates the good from the great. 
&#8211; Bozhidar Batsov</blockquote>


<p>One thing has always bothered me as Ruby developer &ndash; Python developers have a great programming style reference (<a href="http://www.python.org/dev/peps/pep-0008/">PEP-8</a>) and we never got an official guide, documenting Ruby coding style and best practices. And I do believe that style matters. I also believe that such fine fellows, like us Ruby developers, should be quite capable to produce this coveted document.</p>

<p>This guide started its life as our internal company Ruby coding guidelines (written by yours truly). At some point I decided that the work I was doing might be interesting to members of the Ruby community in general and that the world had little need for another internal company guideline. But the world could certainly benefit from a community-driven and community-sanctioned set of practices, idioms and style prescriptions for Ruby programming.</p>

<p>Since the inception of the guide I&rsquo;ve received a lot of feedback from members of the exceptional Ruby community around the world. Thanks for all the suggestions and the support! Together we can make a resource beneficial to each and every Ruby developer out there.</p>

<p>By the way, if you&rsquo;re into Rails you might want to check out the complementary <a href="https://github.com/bbatsov/rails-style-guide">Ruby on Rails 3 Style Guide</a>.</p>

<h1>The Ruby Style Guide</h1>


<p>This Ruby style guide recommends best practices so that real-world Ruby programmers can write code that can be maintained by other real-world Ruby programmers. A style guide that reflects real-world usage gets used, and a style guide that holds to an ideal that has been rejected by the people it is supposed to help risks not getting used at all – no matter how good it is.</p>

<p>The guide is separated into several sections of related rules. I&rsquo;ve tried to add the rationale behind the rules (if it&rsquo;s omitted I&rsquo;ve assumed that is pretty obvious).</p>

<p>I didn&rsquo;t come up with all the rules out of nowhere &ndash; they are mostly based on my extensive career as a professional software engineer, feedback and suggestions from members of the Ruby community and various highly regarded Ruby programming resources, such as<a href="http://pragprog.com/book/ruby3/programming-ruby-1-9">&ldquo;Programming Ruby 1.9&rdquo;</a> and <a href="http://www.amazon.com/Ruby-Programming-Language-David-Flanagan/dp/0596516177">&ldquo;The Ruby Programming Language&rdquo;</a>.</p>

<p>The guide is still a work in progress &ndash; some rules are lacking examples, some rules don&rsquo;t have examples that illustrate them clearly enough. In due time these issues will be addressed &ndash; just keep them in mind for now.</p>

<p>You can generate a PDF or an HTML copy of this guide using <a href="https://github.com/TechnoGate/transmuter">Transmuter</a>.</p>

<h2>Source Code Layout</h2>


<blockquote>Nearly everybody is convinced that every style but their own is ugly and unreadable. Leave out the &#8220;but their own&#8221; and they&#8217;re probably right&#8230; 
&#8211; Jerry Coffin (on indentation)</blockquote>


<ul>
    <li>Use <code>UTF-8</code> as the source file encoding.</li>
    <li>Use two <strong>spaces</strong> per indentation level.
<div>
<pre># good
def some_method
  do_something
end

# bad - four spaces
def some_method
    do_something
end</pre>
</div></li>
    <li>Use Unix-style line endings. (*BSD/Solaris/Linux/OSX users are covered by default, Windows users have to be extra careful.)
<ul>
    <li>If you&#8217;re using Git you might want to add the following configuration setting to protect your project from Windows line endings creeping in:

<code>$ git config --global core.autocrlf true</code></li>
</ul>
</li>
    <li>Use spaces around operators, after commas, colons and semicolons, around <code>{</code> and before <code>}</code>. Whitespace might be (mostly) irrelevant to the Ruby interpreter, but its proper use is the key to writing easily readable code.
<div>
<pre>sum = 1 + 2
a, b = 1, 2
1 &gt; 2 ? true : false; puts 'Hi'
[1, 2, 3].each { |e| puts e }</pre>
</div>
The only exception is when using the exponent operator:
<div>
<pre># bad
e = M * c ** 2

# good
e = M * c**2</pre>
</div></li>
    <li>No spaces after <code>(</code>, <code>[</code> or before <code>]</code>, <code>)</code>.
<div>
<pre>some(arg).other
[1, 2, 3].length</pre>
</div></li>
    <li>Indent <code>when</code> as deep as <code>case</code>. I know that many would disagree with this one, but it&#8217;s the style established in both the &#8220;The Ruby Programming Language&#8221; and &#8220;Programming Ruby&#8221;.
<div>
<pre>case
when song.name == 'Misty'
  puts 'Not again!'
when song.duration &gt; 120
  puts 'Too long!'
when Time.now.hour &gt; 21
  puts "It's too late"
else
  song.play
end

kind = case year
       when 1850..1889 then 'Blues'
       when 1890..1909 then 'Ragtime'
       when 1910..1929 then 'New Orleans Jazz'
       when 1930..1939 then 'Swing'
       when 1940..1950 then 'Bebop'
       else 'Jazz'
       end</pre>
</div></li>
    <li>Use empty lines between <code>def</code>s and to break up a method into logical paragraphs.
<div>
<pre>def some_method
  data = initialize(options)

  data.manipulate!

  data.result
end

def some_method
  result
end</pre>
</div></li>
    <li>Align the parameters of a method call if they span over multiple lines.
<div>
<pre># starting point (line is too long)
def send_mail(source)
  Mailer.deliver(to: 'bob@example.com', from: 'us@example.com', subject: 'Important message', body: source.text)
end

# bad (normal indent)
def send_mail(source)
  Mailer.deliver(
    to: 'bob@example.com',
    from: 'us@example.com',
    subject: 'Important message',
    body: source.text)
end

# bad (double indent)
def send_mail(source)
  Mailer.deliver(
      to: 'bob@example.com',
      from: 'us@example.com',
      subject: 'Important message',
      body: source.text)
end

# good
def send_mail(source)
  Mailer.deliver(to: 'bob@example.com',
                 from: 'us@example.com',
                 subject: 'Important message',
                 body: source.text)
end</pre>
</div></li>
    <li>Use RDoc and its conventions for API documentation. Don&#8217;t put an empty line between the comment block and the <code>def</code>.</li>
    <li>Keep lines fewer than 80 characters.</li>
    <li>Avoid trailing whitespace.</li>
</ul>


<h2>Syntax</h2>


<ul>
    <li>Use <code>def</code> with parentheses when there are arguments. Omit the parentheses when the method doesn&#8217;t accept any arguments.
<div>
<pre> def some_method
   # body omitted
 end

 def some_method_with_arguments(arg1, arg2)
   # body omitted
 end</pre>
</div></li>
    <li>Never use <code>for</code>, unless you know exactly why. Most of the time iterators should be used instead. <code>for</code> is implemented in terms of<code>each</code> (so you&#8217;re adding a level of indirection), but with a twist - <code>for</code> doesn&#8217;t introduce a new scope (unlike <code>each</code>) and variables defined in its block will be visible outside it.
<div>
<pre>arr = [1, 2, 3]

# bad
for elem in arr do
  puts elem
end

# good
arr.each { |elem| puts elem }</pre>
</div></li>
    <li>Never use <code>then</code> for multi-line <code>if/unless</code>.
<div>
<pre># bad
if some_condition then
  # body omitted
end

# good
if some_condition
  # body omitted
end</pre>
</div></li>
    <li>Favor the ternary operator(<code>?:</code>) over <code>if/then/else/end</code> constructs. It&#8217;s more common and obviously more concise.
<div>
<pre># bad
result = if some_condition then something else something_else end

# good
result = some_condition ? something : something_else</pre>
</div></li>
    <li>Use one expression per branch in a ternary operator. This also means that ternary operators must not be nested. Prefer <code>if/else</code>constructs in these cases.
<div>
<pre># bad
some_condition ? (nested_condition ? nested_something : nested_something_else) : something_else

# good
if some_condition
  nested_condition ? nested_something : nested_something_else
else
  something_else
end</pre>
</div></li>
    <li>Never use <code>if x: ...</code> - it is removed in Ruby 1.9. Use the ternary operator instead.
<div>
<pre># bad
result = if some_condition: something else something_else end

# good
result = some_condition ? something : something_else</pre>
</div></li>
    <li>Never use <code>if x; ...</code>. Use the ternary operator instead.</li>
    <li>Use <code>when x then ...</code> for one-line cases. The alternative syntax <code>when x: ...</code> is removed in Ruby 1.9.</li>
    <li>Never use <code>when x; ...</code>. See the previous rule.</li>
    <li>Use <code>&amp;&amp;/||</code> for boolean expressions, <code>and/or</code> for control flow. (Rule of thumb: If you have to use outer parentheses, you are using the wrong operators.)
<div>
<pre># boolean expression
if some_condition &amp;&amp; some_other_condition
  do_something
end

# control flow
document.saved? or document.save!</pre>
</div></li>
    <li>Avoid multi-line <code>?:</code> (the ternary operator), use <code>if/unless</code> instead.</li>
    <li>Favor modifier <code>if/unless</code> usage when you have a single-line body. Another good alternative is the usage of control flow <code>and/or</code>.
<div>
<pre># bad
if some_condition
  do_something
end

# good
do_something if some_condition

# another good option
some_condition and do_something</pre>
</div></li>
    <li>Favor <code>unless</code> over <code>if</code> for negative conditions (or control flow <code>or</code>).
<div>
<pre># bad
do_something if !some_condition

# good
do_something unless some_condition

# another good option
some_condition or do_something</pre>
</div></li>
    <li>Never use <code>unless</code> with <code>else</code>. Rewrite these with the positive case first.
<div>
<pre># bad
unless success?
  puts 'failure'
else
  puts 'success'
end

# good
if success?
  puts 'success'
else
  puts 'failure'
end</pre>
</div></li>
    <li>Don&#8217;t use parentheses around the condition of an <code>if/unless/while</code>, unless the condition contains an assignment (see &#8220;Using the return value of <code>=</code>&#8221; below).
<div>
<pre># bad
if (x &gt; 10)
  # body omitted
end

# good
if x &gt; 10
  # body omitted
end

# ok
if (x = self.next_value)
  # body omitted
end</pre>
</div></li>
    <li>Omit parentheses around parameters for methods that are part of an internal DSL (e.g. Rake, Rails, RSpec), methods that are with &#8220;keyword&#8221; status in Ruby (e.g. <code>attr_reader</code>, <code>puts</code>) and attribute access methods. Use parentheses around the arguments of all other method invocations.
<div>
<pre>class Person
  attr_reader :name, :age

  # omitted
end

temperance = Person.new('Temperance', 30)
temperance.name

puts temperance.age

x = Math.sin(y)
array.delete(e)</pre>
</div></li>
    <li>Prefer <code>{...}</code> over <code>do...end</code> for single-line blocks. Avoid using <code>{...}</code> for multi-line blocks (multiline chaining is always ugly). Always use <code>do...end</code> for &#8220;control flow&#8221; and &#8220;method definitions&#8221; (e.g. in Rakefiles and certain DSLs). Avoid <code>do...end</code> when chaining.
<div>
<pre>names = ["Bozhidar", "Steve", "Sarah"]

# good
names.each { |name| puts name }

# bad
names.each do |name|
  puts name
end

# good
names.select { |name| name.start_with?("S") }.map { |name| name.upcase }

# bad
names.select do |name|
  name.start_with?("S")
end.map { |name| name.upcase }</pre>
</div>
Some will argue that multiline chaining would look OK with the use of {&#8230;}, but they should ask themselves - it this code really readable and can&#8217;t the blocks contents be extracted into nifty methods.</li>
    <li>Avoid <code>return</code> where not required.
<div>
<pre># bad
def some_method(some_arr)
  return some_arr.size
end

# good
def some_method(some_arr)
  some_arr.size
end</pre>
</div></li>
    <li>Use spaces around the <code>=</code> operator when assigning default values to method parameters:
<div>
<pre># bad
def some_method(arg1=:default, arg2=nil, arg3=[])
  # do something...
end

# good
def some_method(arg1 = :default, arg2 = nil, arg3 = [])
  # do something...
end</pre>
</div>
While several Ruby books suggest the first style, the second is much more prominent in practice (and arguably a bit more readable).</li>
    <li>Avoid line continuation (\) where not required. In practice, avoid using line continuations at all.
<div>
<pre># bad
result = 1 - \
         2

# good (but still ugly as hell)
result = 1 \
         - 2</pre>
</div></li>
    <li>Using the return value of <code>=</code> (an assignment) is ok, but surround the assignment with parenthesis.
<div>
<pre># good - shows intented use of assignment
if (v = array.grep(/foo/)) ...

# bad
if v = array.grep(/foo/) ...

# also good - shows intended use of assignment and has correct precedence.
if (v = self.next_value) == "hello" ...</pre>
</div></li>
    <li>Use <code>||=</code> freely to initialize variables.
<div>
<pre># set name to Bozhidar, only if it's nil or false
name ||= 'Bozhidar'</pre>
</div></li>
    <li>Don&#8217;t use <code>||=</code> to initialize boolean variables. (Consider what would happen if the current value happened to be <code>false</code>.)
<div>
<pre># bad - would set enabled to true even if it was false
enabled ||= true

# good
enabled = true if enabled.nil?</pre>
</div></li>
    <li>Avoid using Perl-style special variables (like <code>$0-9</code>, <code>$</code>`, etc. ). They are quite cryptic and their use in anything but one-liner scripts is discouraged.</li>
    <li>Never put a space between a method name and the opening parenthesis.
<div>
<pre># bad
f (3 + 2) + 1

# good
f(3 + 2) + 1</pre>
</div></li>
    <li>If the first argument to a method begins with an open parenthesis, always use parentheses in the method invocation. For example, write <code>f((3 + 2) + 1)</code>.</li>
    <li>Always run the Ruby interpreter with the <code>-w</code> option so it will warn you if you forget either of the rules above!</li>
    <li>When the keys of your hash are symbols use the Ruby 1.9 hash literal syntax.
<div>
<pre># bad
hash = { :one =&gt; 1, :two =&gt; 2 }

# good
hash = { one: 1, two: 2 }</pre>
</div></li>
    <li>Use the new lambda literal syntax.
<div>
<pre># bad
lambda = lambda { |a, b| a + b }
lambda.call(1, 2)

# good
lambda = -&gt;(a, b) { a + b }
lambda.(1, 2)</pre>
</div></li>
    <li>Use <code>_</code> for unused block parameters.
<div>
<pre># bad
result = hash.map { |k, v| v + 1 }

# good
result = hash.map { |_, v| v + 1 }</pre>
</div></li>
</ul>


<h2>Naming</h2>


<blockquote>The only real difficulties in programming are cache invalidation and naming things. 
&#8211; Phil Karlton</blockquote>


<ul>
    <li>Use <code>snake_case</code> for methods and variables.</li>
    <li>Use <code>CamelCase</code> for classes and modules. (Keep acronyms like HTTP, RFC, XML uppercase.)</li>
    <li>Use <code>SCREAMING_SNAKE_CASE</code> for other constants.</li>
    <li>The names of predicate methods (methods that return a boolean value) should end in a question mark. (i.e. <code>Array#empty?</code>).</li>
    <li>The names of potentially &#8220;dangerous&#8221; methods (i.e. methods that modify <code>self</code> or the arguments, <code>exit!</code>, etc.) should end with an exclamation mark.</li>
    <li>When using <code>reduce</code> with short blocks, name the arguments <code>|a, e|</code> (accumulator, element).</li>
    <li>When defining binary operators, name the argument <code>other</code>.
<div>
<pre>def +(other)
  # body omitted
end</pre>
</div></li>
    <li>Prefer <code>map</code> over <code>collect</code>, <code>find</code> over <code>detect</code>, <code>select</code> over <code>find_all</code>, <code>reduce</code> over <code>inject</code> and <code>size</code> over <code>length</code>. This is not a hard requirement; if the use of the alias enhances readability, it&#8217;s ok to use it. The rhyming methods are inherited from Smalltalk and are not common in other programming languages. The reason the use of <code>select</code> is encouraged over <code>find_all</code> is that it goes together nicely with <code>reject</code> and its name is pretty self-explanatory.</li>
</ul>


<h2>Comments</h2>


<blockquote>Good code is its own best documentation. As you&#8217;re about to add a comment, ask yourself, &#8220;How can I improve the code so that this comment isn&#8217;t needed?&#8221; Improve the code and then document it to make it even clearer. 
&#8211; Steve McConnell</blockquote>


<ul>
    <li>Write self-documenting code and ignore the rest of this section. Seriously!</li>
    <li>Comments longer than a word are capitalized and use punctuation. Use <a href="http://en.wikipedia.org/wiki/Sentence_spacing">one space</a> after periods.</li>
    <li>Avoid superfluous comments.
<div>
<pre># bad
counter += 1 # increments counter by one</pre>
</div></li>
    <li>Keep existing comments up-to-date. No comment is better than an outdated comment.</li>
    <li>Avoid writing comments to explain bad code. Refactor the code to make it self-explanatory. (Do or do not - there is no try.)</li>
</ul>


<h2>Annotations</h2>


<ul>
    <li>Annotations should usually be written on the line immediately above the relevant code.</li>
    <li>The annotation keyword is followed by a colon and a space, then a note describing the problem.</li>
    <li>If multiple lines are required to describe the problem, subsequent lines should be indented two spaces after the <code>#</code>.
<div>
<pre>def bar
  # FIXME: This has crashed occasionally since v3.2.1. It may
  #   be related to the BarBazUtil upgrade.
  baz(:quux)
end</pre>
</div></li>
    <li>In cases where the problem is so obvious that any documentation would be redundant, annotations may be left at the end of the offending line with no note. This usage should be the exception and not the rule.
<div>
<pre>def bar
  sleep 100 # OPTIMIZE
end</pre>
</div></li>
    <li>Use <code>TODO</code> to note missing features or functionality that should be added at a later date.</li>
    <li>Use <code>FIXME</code> to note broken code that needs to be fixed.</li>
    <li>Use <code>OPTIMIZE</code> to note slow or inefficient code that may cause performance problems.</li>
    <li>Use <code>HACK</code> to note code smells where questionable coding practices were used and should be refactored away.</li>
    <li>Use <code>REVIEW</code> to note anything that should be looked at to confirm it is working as intended. For example:<code>REVIEW: Are we sure this is how the client does X currently?</code></li>
    <li>Use other custom annotation keywords if it feels appropriate, but be sure to document them in your project&#8217;s <code>README</code> or similar.</li>
</ul>


<h2>Classes</h2>


<ul>
    <li>When designing class hierarchies make sure that they conform to the <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov Substitution Principle</a>.</li>
    <li>Try to make your classes as <a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID</a> as possible.</li>
    <li>Always supply a proper <code>to_s</code> method for classes that represent domain objects.
<div>
<pre>class Person
  attr_reader :first_name, :last_name

  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end

  def to_s
    "#@first_name #@last_name"
  end
end</pre>
</div></li>
    <li>Use the <code>attr</code> family of functions to define trivial accessors or mutators.
<div>
<pre># bad
class Person
  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end

  def first_name
    @first_name
  end

  def last_name
    @last_name
  end
end

# good
class Person
  attr_reader :first_name, :last_name

  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end
end</pre>
</div></li>
    <li>Consider adding factory methods to provide additional sensible ways to create instances of a particular class.
<div>
<pre>class Person
  def self.create(options_hash)
    # body omitted
  end
end</pre>
</div></li>
    <li>Prefer <a href="http://en.wikipedia.org/wiki/Duck_typing">duck-typing</a> over inheritance.
<div>
<pre># bad
class Animal
  # abstract method
  def speak
  end
end

# extend superclass
class Duck &lt; Animal
  def speak
    puts 'Quack! Quack'
  end
end

# extend superclass
class Dog &lt; Animal
  def speak
    puts 'Bau! Bau!'
  end
end

# good
class Duck
  def speak
    puts 'Quack! Quack'
  end
end

class Dog
  def speak
    puts 'Bau! Bau!'
  end
end</pre>
</div></li>
    <li>Avoid the usage of class (<code>@@</code>) variables due to their &#8220;nasty&#8221; behavior in inheritance.
<div>
<pre>class Parent
  @@class_var = 'parent'

  def self.print_class_var
    puts @@class_var
  end
end

class Child &lt; Parent
  @@class_var = 'child'
end

Parent.print_class_var # =&gt; will print "child"</pre>
</div>
As you can see all the classes in a class hierarchy actually share one class variable. Class instance variables should usually be preferred over class variables.</li>
    <li>Assign proper visibility levels to methods (<code>private</code>, <code>protected</code>) in accordance with their intended usage. Don&#8217;t go off leaving everything <code>public</code> (which is the default). After all we&#8217;re coding in <em>Ruby</em> now, not in <em>Python</em>.</li>
    <li>Indent the <code>public</code>, <code>protected</code>, and <code>private</code> methods as much the method definitions they apply to. Leave one blank line above them.
<div>
<pre>class SomeClass
  def public_method
    # ...
  end

  private
  def private_method
    # ...
  end
end</pre>
</div></li>
    <li>Use <code>def self.method</code> to define singleton methods. This makes the methods more resistant to refactoring changes.
<div>
<pre>class TestClass
  # bad
  def TestClass.some_method
    # body omitted
  end

  # good
  def self.some_other_method
    # body omitted
  end

  # Also possible and convenient when you
  # have to define many singleton methods.
  class &lt;&lt; self
    def first_method
      # body omitted
    end

    def second_method_etc
      # body omitted
    end
  end
end</pre>
</div></li>
</ul>


<h2>Exceptions</h2>


<ul>
    <li>Don&#8217;t suppress exceptions.
<div>
<pre>begin
  # an exception occurs here
rescue SomeError
  # the rescue clause does absolutely nothing
end</pre>
</div></li>
    <li>Don&#8217;t use exceptions for flow of control.
<div>
<pre># bad
begin
  n / d
rescue ZeroDivisionError
  puts "Cannot divide by 0!"
end

# good
if n.zero?
  puts "Cannot divide by 0!"
else
  n / d</pre>
</div></li>
    <li>Avoid rescuing the <code>Exception</code> class.
<div>
<pre># bad 
begin
  # an exception occurs here
rescue
  # exception handling
end

# still bad
begin
  # an exception occurs here
rescue Exception
  # exception handling
end</pre>
</div></li>
    <li>Put more specific exceptions higher up the rescue chain, otherwise they&#8217;ll never be rescued from.
<div>
<pre># bad
begin
  # some code
rescue Exception =&gt; e
  # some handling
rescue StandardError =&gt; e
  # some handling
end

# good
begin
  # some code
rescue StandardError =&gt; e
  # some handling
rescue Exception =&gt; e
  # some handling
end</pre>
</div></li>
    <li>Release external resources obtained by your program in an ensure block.
<div>
<pre>f = File.open("testfile")
begin
  # .. process
rescue
  # .. handle error
ensure
  f.close unless f.nil?
end</pre>
</div></li>
    <li>Favor the use of exceptions for the standard library over introducing new exception classes.</li>
</ul>


<h2>Collections</h2>


<ul>
    <li>Prefer <code>%w</code> to the literal array syntax when you need an array of strings.
<div>
<pre># bad
STATES = ['draft', 'open', 'closed']

# good
STATES = %w(draft open closed)</pre>
</div></li>
    <li>Avoid the creation of huge gaps in arrays.
<div>
<pre>arr = []
arr[100] = 1 # now you have an array with lots of nils</pre>
</div></li>
    <li>Use <code>Set</code> instead of <code>Array</code> when dealing with unique elements. <code>Set</code> implements a collection of unordered values with no duplicates. This is a hybrid of <code>Array</code>&#8217;s intuitive inter-operation facilities and <code>Hash</code>&#8217;s fast lookup.</li>
    <li>Use symbols instead of strings as hash keys.
<div>
<pre># bad
hash = { 'one' =&gt; 1, 'two' =&gt; 2, 'three' =&gt; 3 }

# good
hash = { one: 1, two: 2, three: 3 }</pre>
</div></li>
    <li>Avoid the use of mutable object as hash keys.</li>
    <li>Use the new 1.9 literal hash syntax in preference to the hashrocket syntax.
<div>
<pre># bad
hash = { :one =&gt; 1, :two =&gt; 2, :three =&gt; 3 }

# good
hash = { one: 1, two: 2, three: 3 }</pre>
</div></li>
    <li>Rely on the fact that hashes in 1.9 are ordered.</li>
    <li>Never modify a collection while traversing it.</li>
</ul>


<h2>Strings</h2>


<ul>
    <li>Prefer string interpolation instead of string concatenation:
<div>
<pre># bad
email_with_name = user.name + ' &lt;' + user.email + '&gt;'

# good
email_with_name = "#{user.name} &lt;#{user.email}&gt;"</pre>
</div></li>
    <li>Prefer single-quoted strings when you don&#8217;t need string interpolation or special symbols such as <code>\t</code>, <code>\n</code>, <code>'</code>, etc.
<div>
<pre># bad
name = "Bozhidar"

# good
name = 'Bozhidar'</pre>
</div></li>
    <li>Don&#8217;t use <code>{}</code> around instance variables being interpolated into a string.
<div>
<pre>class Person
  attr_reader :first_name, :last_name

  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end

  # bad
  def to_s
    "#{@first_name} #{@last_name}"
  end

  # good
  def to_s
    "#@first_name #@last_name"
  end
end</pre>
</div></li>
    <li>Avoid using <code>String#+</code> when you need to construct large data chunks. Instead, use <code>String#&lt;&lt;</code>. Concatenation mutates the string instance in-place and is always faster than <code>String#+</code>, which creates a bunch of new string objects.
<div>
<pre># good and also fast
html = ''
html &lt;&lt; '&lt;h1&gt;Page title&lt;/h1&gt;'

paragraphs.each do |paragraph|
  html &lt;&lt; "&lt;p&gt;#{paragraph}&lt;/p&gt;"
end</pre>
</div></li>
</ul>


<h2>Regular Expressions</h2>


<ul>
    <li>Don&#8217;t use regular expressions if you just need plain text search in string: <code>string['text']</code></li>
    <li>For simple constructions you can use regexp directly through string index.
<div>
<pre>match = string[/regexp/]             # get content of matched regexp
first_group = string[/text(grp)/, 1] # get content of captured group
string[/text (grp)/, 1] = 'replace'  # string =&gt; 'text replace'</pre>
</div></li>
    <li>Use non capturing groups when you don&#8217;t use captured result of parenthesis.
<div>
<pre>/(first|second)/   # bad
/(?:first|second)/ # good</pre>
</div></li>
    <li>Avoid using $1-9 as it can be hard to track what they contain. Named groups can be used instead.
<div>
<pre># bad
/(regexp)/ =~ string
...
process $1

# good
/(?&lt;meaningful_var&gt;regexp)/ =~ string
...
process meaningful_var</pre>
</div></li>
    <li>Character classes have only few special characters you should care about: <code>^</code>, <code>-</code>, <code>\</code>, <code>]</code>, so don&#8217;t escape <code>.</code> or brackets in<code>[]</code>.</li>
    <li>Be careful with <code>^</code> and <code>$</code> as they match start/end of line, not string endings. If you want to match the whole string use: <code>\A</code> and<code>\Z</code>.
<div>
<pre>string = "some injection\nusername"
string[/^username$/]   # matches
string[/\Ausername\Z/] # don't match</pre>
</div></li>
    <li>Use <code>x</code> modifier for complex regexps. This makes them more readable and you can add some useful comments. Just be careful as spaces are ignored.
<div>
<pre>regexp = %r{
  start         # some text
  \s            # white space char
  (group)       # first group
  (?:alt1|alt2) # some alternation
  end
}x</pre>
</div></li>
    <li>For complex replacements <code>sub</code>/<code>gsub</code> can be used with block or hash.</li>
</ul>


<h2>Percent Literals</h2>


<ul>
    <li>Use <code>%w</code> freely.
<div>
<pre>STATES = %w(draft open closed)</pre>
</div></li>
    <li>Use <code>%()</code> for single-line strings which require both interpolation and embedded double-quotes. For multi-line strings, prefer heredocs.
<div>
<pre># bad (no interpolation needed)
%(&lt;div&gt;Some text&lt;/div&gt;)
# should be '&lt;div&gt;Some text&lt;/div&gt;'

# bad (no double-quotes)
%(This is #{quality} style)
# should be "This is #{quality} style"

# bad (multiple lines)
%(&lt;div&gt;\n&lt;span&gt;#{exclamation}&lt;/span&gt;\n&lt;/div&gt;)
# should be a heredoc.

# good (requires interpolation, has quotes, single line)
%(&lt;tr&gt;&lt;td&gt;#{name}&lt;/td&gt;)</pre>
</div></li>
    <li>Use <code>%r</code> only for regular expressions matching <em>more than</em> one &#8216;/&#8217; character.
<div>
<pre># bad
%r(\s+)

# still bad
%r(^/(.*)$)
# should be /^\/(.*)$/

# good
%r(^/blog/2011/(.*)$)</pre>
</div></li>
    <li>Avoid <code>%q</code>, <code>%Q</code>, <code>%x</code>, <code>%s</code>, and <code>%W</code>.</li>
    <li>Prefer <code>()</code> as delimiters for all <code>%</code> literals.</li>
</ul>


<h2>Metaprogramming</h2>


<ul>
    <li>Do not mess around in core classes when writing libraries. (Do not monkey patch them.)</li>
</ul>


<h2>Misc</h2>


<ul>
    <li>Write <code>ruby -w</code> safe code.</li>
    <li>Avoid hashes as optional parameters. Does the method do too much?</li>
    <li>Avoid methods longer than 10 LOC (lines of code). Ideally, most methods will be shorter than 5 LOC. Empty lines do not contribute to the relevant LOC.</li>
    <li>Avoid parameter lists longer than three or four parameters.</li>
    <li>If you really have to, add &#8220;global&#8221; methods to Kernel and make them private.</li>
    <li>Use class instance variables instead of global variables.
<div>
<pre>#bad
$foo_bar = 1

#good
class Foo
  class &lt;&lt; self
    attr_accessor :bar
  end
end

Foo.bar = 1</pre>
</div></li>
    <li>Avoid <code>alias</code> when <code>alias_method</code> will do.</li>
    <li>Use <code>OptionParser</code> for parsing complex command line options and <code>ruby -s</code> for trivial command line options.</li>
    <li>Code in a functional way, avoiding mutation when that makes sense.</li>
    <li>Avoid needless metaprogramming.</li>
    <li>Do not mutate arguments unless that is the purpose of the method.</li>
    <li>Avoid more than three levels of block nesting.</li>
    <li>Be consistent. In an ideal world, be consistent with these guidelines.</li>
    <li>Use common sense.</li>
</ul>


<h1>Contributing</h1>


<p>Nothing written in this guide is set in stone. It&rsquo;s my desire to work together with everyone interested in Ruby coding style, so that we could ultimately create a resource that will be beneficial to the entire Ruby community.</p>

<p>Feel free to open tickets or send pull requests with improvements. Thanks in advance for your help!</p>

<h1>Spread the Word</h1>


<p>A community-driven style guide is of little use to a community that doesn&rsquo;t know about its existence. Tweet about the guide, share it with your friends and colleagues. Every comment, suggestion or opinion we get makes the guide just a little bit better. And we want to have the best possible guide, don&rsquo;t we?</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/29/ruby-style-guide-zh-cn/">Ruby-style-guide-zh-cn</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-29T23:35:00+08:00" pubdate data-updated="true">Mar 29<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>ruby-style-guide-zh-cn</h2>

<h1>序</h1>


<blockquote>风格可以用来区分从好到卓越。
&#8211; Bozhidar Batsov</blockquote>


<p>有一件事情总是困扰着，作为Ruby程序员的我 &ndash; python 开发者都有一个很棒的编程风格参考 (<a href="http://www.python.org/dev/peps/pep-0008/">PEP-8</a>)，然而我们从没有一个官方的（公认）的guide，Ruby代码风格文档和最佳实践。而且我信赖这些风格（的一些约定）。我也相信下面的一些好东西，像我们这样的Ruby开发者，也应该有能力写出这样的梦寐以求的文档。</p>

<p>这份指南诞生于我们公司内部的Ruby编程准则，基于Ruby社区的大多数成员会对我正在做的有兴趣这样的发点，我决定做这样的工作，而且世界上很少需要另一个公司内部的（编程）准则。但是这个世界将会一定有益于社区驱动的以及社区认可的，Ruby习惯和风格实践。</p>

<p>自从这个guide（发表）以来，我收到了很多来自优秀的Ruby社区的世界范围内的成员的回馈。感谢所有的建议和支持！集我们大家之力，我们可以创作出对每一个Ruby开发人员有益的资源。</p>

<p>补充，如果你正在使用rails你可能会希望查阅<a href="https://github.com/bbatsov/rails-style-guide">Ruby on Rails 3 Style Guide</a>.</p>

<h1>Ruby 风格指南</h1>


<p>这个Ruby风格指南推荐（一些）最佳实践使得现实世界中的Ruby程序员可以写出能够被其他真是世界的Ruby程序员维护的代码。一个风格指南反映了真实世界的使用习惯，同时一个风格指南紧紧把握一个观点那就是人们拒绝接受任何有可能无法使用指南的风险，无论它多好。</p>

<p>这个指南被分为几个具有相关的rules的几节。我尝试给rules添加合理的解释（如果它被省略我假设它相当的明显了）。</p>

<p>我并没有列举所有的rules &ndash; 它们大多数基于我作为一个专业的软件工程师的广泛生涯，回馈和来自Ruby社区成员的建议以及各种备受推崇的Ruby编程资源，例如<a href="http://pragprog.com/book/ruby3/programming-ruby-1-9">&ldquo;Programming Ruby 1.9&rdquo;</a> 和 <a href="http://www.amazon.com/Ruby-Programming-Language-David-Flanagan/dp/0596516177">&ldquo;The Ruby Programming Language&rdquo;</a>.</p>

<p>这个指南仍然在工作进程中 &ndash; 一些rules缺乏例子，一些rules没有合适的例子来使得它们足够明了。</p>

<p>你可以使用<a href="https://github.com/TechnoGate/transmuter">Transmuter</a>.来生成指南的PDF或者HTML的copy。</p>

<h2>源代码布局</h2>


<blockquote>附近的每个人都深信每一个风格除了他们自己的都是 丑陋的并且难以阅读的。脱离&#8221;but their own&#8221;那么他们 完全正确&#8230; 
&#8211; Jerry Coffin (on indentation缩进)</blockquote>


<ul>
    <li>使用 <code>UTF-8</code> 作为源文件编码。</li>
    <li>每个缩进级别使用两个 <strong>spaces</strong>
<div>
<pre># good
def some_method
  do_something
end

# bad - four spaces
def some_method
    do_something
end</pre>
</div></li>
    <li>使用Unix-风格行结束。(*BSD/Solaris/Linux/OSX 用户被涵盖为默认，Windows 用户必须特别小心.) &gt; \n是换行，英文是LineFeed，ASCII码是0xA。 &gt; \r是回车，英文是Carriage Return ,ASCII码是0xD。 &gt; windows下enter是 \n\r,unix下是\n,mac下是\r
<ul>
    <li>如果你正在使用Git你可能会想要添加下面的配置设置来保护你的项目（避免）Windows蔓延过来的行结束符:<code>$ git config --global core.autecrlf true</code></li>
</ul>
</li>
    <li>使用空格：在操作符旁；逗号，冒号和分号后；在 <code>{</code>旁和在 <code>}</code>之前，大多数空格可能对Ruby解释（代码）无关，但是它的恰当使用是让代码变得易读的关键。
<div>
<pre>sum = 1 + 2
a, b = 1, 2
1 &gt; 2 ? true : false; puts 'Hi'
[1, 2, 3].each { |e| puts e }</pre>
</div>
唯一的例外是当使用指数操作时：
<div>
<pre># bad
e = M * c ** 2

# good
e = M * c**2</pre>
</div></li>
    <li>没有空格 <code>(</code>, <code>[</code>之后或者 <code>]</code>, <code>)</code>之前。
<div>
<pre>some(arg).other
[1, 2, 3].length</pre>
</div></li>
    <li><code>when</code>和<code>case</code> 缩进深度一致。我知道很多人会不同意这点，但是它是&#8221;The Ruby Programming Language&#8221; 和 &#8220;Programming Ruby&#8221;中公认的风格。
<div>
<pre>case
when song.name == 'Misty'
  puts 'Not again!'
when song.duraton &gt; 120
  puts 'Too long!'
when Time.now &gt; 21
  puts "It's too late"
else
  song.play
end

kind = case year
       when 1850..1889 then 'Blues'
       when 1890..1909 then 'Ragtime'
       when 1910..1929 then 'New Orleans Jazz'
       when 1930..1939 then 'Swing'
       when 1940..1950 then 'Bebop'
       else 'Jazz'
       end</pre>
</div></li>
    <li>使用空行在 <code>def</code>s 并且一个方法根据逻辑段来隔开。
<div>
<pre>def some_method
  data = initialize(options)

  data.manipulate!

  data.result
end

def some_methods
  result
end</pre>
</div></li>
    <li>如果一个方法的调用参数分割为多行将它们于<strong>方法名</strong>对齐。
<div>
<pre># starting point (line is too long)
def send_mail(source)
  Mailer.deliver(to: 'bob@example.com', from: 'us@example.com', subject: 'Important message', body: source.text)
end
# bad (normal indent)
def send_mail(source)
  Mailer.deliver(
    to: 'bob@example.com',
    from: 'us@example.com',
    subject: 'Important message',
    body: source.text)
end

# bad (double indent)
def send_mail(source)
  Mailer.deliver(
      to: 'bob@example.com',
      from: 'us@example.com',
      subject: 'Important message',
      body: source.text)
end
# good
def send_mail(source)
  Mailer.deliver(to: 'bob@example.com',
                 from: 'us@example.com',
                 subject: 'Important message',
                 body: source.text)
end</pre>
</div></li>
    <li>在 API 文档中使用 RDoc和它的公约。不要在注释代码块和<code>def</code>之间加入空行。</li>
    <li>保持每一行少于80字符。</li>
    <li>避免尾随空格。</li>
</ul>


<h2>语法</h2>


<ul>
    <li>使用括号将<code>def</code>的参数括起来。当方法不接收任何参数的时候忽略括号。
<div>
<pre>def some_method
  # body omitted
end

def some_method_with_arguments(arg1, arg2)
  # body omitted
end</pre>
</div></li>
    <li>从来不要使用 <code>for</code>， 除非你知道使用它的准确原因。大多数时候迭代器都可以用来替代for。<code>for</code> is implemented in terms of<code>each</code>#<code>for</code>是<code>each</code>的组实现 (因此你正间接添加了一级)，但是有一个小道道 - <code>for</code>并不包含一个新的scope(不像<code>each</code>)并且在它的块中定义的变量在外面也是可以访问的。
<div>
<pre>arr = [1, 2, 3]

# bad
for elem in arr do 
  puts elem
end

puts elem # =&gt; 3

# good
arr.each { |elem| puts elem }</pre>
</div></li>
    <li>在多行的<code>if/unless</code>中坚决不要使用<code>then</code>.
<div>
<pre># bad
if some_condition then
  # body omitten
end

# good
if some_condition
  # body omitted
end</pre>
</div></li>
    <li>喜欢三元操作运算（<code>?:</code>）超过<code>if/then/else/end</code>结果。 它更加普遍而且明显的更加简洁。
<div>
<pre># bad
result = if some_condition then something else something_else end

# good
result = some_condition ? something : something_else</pre>
</div></li>
    <li>使用一个表达式在三元操作运算的每一个分支下面只使用一个表达式。也就是说三元操作符不要被嵌套。在这样的情形中宁可使用<code>if/else</code>。
<div>
<pre># bad
some_condition ? (nested_condition ? nested_something : nested_something_else) : something_else

# good
if some_condition
  nested_condition ? nested_something : nested_something_else
else
  something_else
end</pre>
</div></li>
    <li>使用三元操作运算代替<code>if x: ...</code>。</li>
    <li>在 one-line cases 的时候使用<code>when x then ...</code>。替代的语法<code>when x: xxx</code>已经在Ruby 1.9中移除。</li>
    <li>不要使用<code>when x; ...</code>。查看上面的规则。</li>
    <li>布尔表达式使用<code>&amp;&amp;/||</code>, <code>and/of</code>用于控制流程。（经验Rule:如果你必须使用额外的括号（表达逻辑），那么你正在使用错误的的操作符。）
<div>
<pre># boolean expression
if some_condition &amp;&amp; some_other_condition
  do_something
end

# control flow
document.save? or document.save!</pre>
</div></li>
    <li>避免多行<code>?:</code>(三元操作运算)，使用<code>if/unless</code>替代。</li>
    <li>在单行语句的时候喜爱使用<code>if/unless</code>修饰符。另一个好的选择就是使<code>and/of</code>来做流程控制。
<div>
<pre># bad
if some_condition
  do_something
end

# good
do_something if some_condition

# another good option
some_condition and do_something</pre>
</div></li>
    <li>在否定条件下喜欢<code>unless</code>超过<code>if</code>(或者控制流程 <code>or</code>)。
<div>
<pre># bad
do_something if !some_condition

# good
do_something unless some_condition

# another good option
some_condition or do_something</pre>
</div></li>
    <li>不要使用<code>else</code>搭配<code>unless</code>。将其的语义重写为肯定形式。
<div>
<pre># bad
unless sucess?
  puts 'failure'
else
  puts 'sucess'
end

# good
if sucess?
  puts 'sucess'
else
  puts 'failure'
end</pre>
</div></li>
    <li>不要在<code>if/unless/while</code>将条件旁括起来，除非这个条件包含一个参数(参见下面 &#8220;使用<code>=</code>返回值&#8221;)。
<div>
<pre># bad
if (x&gt;10)
  # body omitted
end

# good
if x &gt; 10
  # body omitted
end

# ok
if (x = self.next_value)
  # body omitted
end</pre>
</div></li>
    <li>DSL(e.g. Rake, Rails, RSpec)里的方法，Ruby“关键字”方法(e.g. <code>attr_reader</code>, <code>puts</code>)以及属性访问方法，所带参数忽略括号。使用括号将在其他方法调用的参数括起来。
<div>
<pre>class Person
  attr_reader :name, :age

  # omitted
end

temperance = Person.new('Temperance', 30)
temperance.name

puts temperance.age

x = Math.sin(y)
array.delete(e)</pre>
</div></li>
    <li>在单行代码块的时候宁愿使用<code>{...}</code>而不是<code>do...end</code>。避免在多行代码块使用<code>{...}</code>(多行链式通常变得非常丑陋)。通常使用<code>do...end</code>来做<code>流程控制</code>和<code>方法定义</code>(例如 在Rakefiles和某些DSLs中)。避免在链式调用中使用<code>do...end</code>。
<div>
<pre>names = ["Bozhidar", "Steve", "Sarah"]

#good
names.each { |name| puts name }

#bad
names.each do |name|
  puts name
end

# good
names.select { |name| name.start_with?("S") }.map { |name| name.upcase }

# bad
names.select do |name|
  name.start_with?("S")
end.map { |name| name.upcase }</pre>
</div>
有人会争论多行链式看起来和使用<code>{...}</code>一样工作，但是他们问问自己 - 这样的代码真的有可读性码并且为什么代码块中的内容不能被提取到美丽的methods。</li>
    <li>避免在不需要的地方使用<code>return</code>
<div>
<pre># bad
def some_method(some_arr)
  return some_arr.size
end

# good
def some_method(some_arr)
  some_arr.size
end</pre>
</div></li>
    <li>当分配默认值给方法参数的时候，在<code>=</code>附近使用空格。
<div>
<pre># bad
def some_method(arg1=:default, arg2=nil, arg3=[])
  # do something...
end

# good
def some_method(arg1 = :default, arg2 = nil, arg3 = [])
  # do something...
end</pre>
</div></li>
    <li>避免在不需要的时候使用行连接符(<code>\\</code>)。实际上应该避免行连接符。
<div>
<pre># bad
result = 1 - \
         2

# good (but still ugly as hell)仍然像地狱一样丑陋
result = 1 \
         - 2</pre>
</div></li>
    <li>使用<code>=</code>返回一个表达式的值是很好的，但是需要用括号把赋值运算式括起来。
<div>
<pre># good - show intented use of assignment
if (v = array.grep(/foo/)) ...

# bad
if v = array.grep(/foo/) ...

# also good - show intended use of assignment and has correct precedence.
if (v = self.next_value) == "hello" ...</pre>
</div></li>
    <li>使用<code>||=</code>轻松的初始化变量。
<div>
<pre># set name to Vozhidar, only if it's nil or false
name ||= 'Bozhidar'</pre>
</div></li>
    <li>不要使用<code>||=</code>来初始化布尔变量。（思考一些如果当前值为<code>false</code>的时候会发生什么。）
<div>
<pre># bad - would set enabled to true even if it was false
enable ||= true

# good
enabled = true if enabled.nil?</pre>
</div></li>
    <li>避免使用Perl的指定变量风格（比如，<code>$0-9</code>，<code>$</code>，等等。）。它们相当神秘，不鼓励在单行代码之外使用它们。</li>
    <li>从来不要在方法名和（参数）开括号之间使用空格。
<div>
<pre># bad
f (3+2) + 1

# good
f(3 + 2) +1</pre>
</div></li>
    <li>如果方法的第一个参数以开括号开始，通常使用括号把它们全部括起来。例如<code>f((3 + 2) + 1)</code>。</li>
    <li>通常使用-w 选项运行Ruby解释器，在你忘记上面所诉规则，ruby将会提示你。</li>
    <li>当你的hash字典是symbols的时候，使用Ruby 1.9的字面量语法。
<div>
<pre># bad
hash = { :one =&gt; 1, :two =&gt; 2 }

#good
hash = { one: 1, two: 2 }</pre>
</div></li>
    <li>使用新的 lambda 语法。
<div>
<pre># bad
lambda = lambda { |a, b| a + b }
lambda.call(1, 2)

# good
lambda = -&gt;(a, b) { a + b }
lambda.(1, 2)</pre>
</div></li>
    <li>对不使用的块变量使用<code>_</code>。
<div>
<pre># bad
result = hash.map { |k, v| v + 1}

# good
result = hash.map { |_, v| v + 1 }</pre>
</div></li>
</ul>


<h3>命名</h3>


<blockquote>The only real difficulties in programming are cache invalidation and naming things. 
&#8211; Phil Karlton 程序（运行）中唯一不一样的是无效的缓存和命名的事物（变量）。
&#8211; Phil Karlton</blockquote>


<ul>
    <li>使用<code>snake_case</code>的形式给变量和方法命名。</li>
    <li>Snake case: punctuation is removed and spaces are replaced by single underscores. Normally the letters share the same case (either UPPER_CASE_EMBEDDED_UNDERSCORE or lower_case_embedded_underscore) but the case can be mixed</li>
    <li>使用<code>CamelCase(駝峰式大小寫)</code>的形式给类和模块命名。(保持使用缩略首字母大写的方式如HTTP, RFC, XML)</li>
    <li>使用<code>SCREAMING_SNAKE_CASE</code>给常量命名。</li>
    <li>在表示断言的方法名（方法返回真或者假）的末尾添加一个问号（如Array#empty?）。</li>
    <li>可能会造成潜在“危险”的方法名（如修改self或者在原处修改变量的方法，exit!等）应该在末尾添加一个感叹号。</li>
    <li>当在短的块中使用<code>reduce</code>时，命名参数<code>|a, e|</code> (accumulator, element)。
<div>
<pre>#Combines all elements of enum枚举 by applying a binary operation, specified by a block or a symbol that names a method or operator.
# Sum some numbers
(5..10).reduce(:+)                            #=&gt; 45#reduce
# Same using a block and inject
(5..10).inject {|sum, n| sum + n }            #=&gt; 45 #inject注入
# Multiply some numbers
(5..10).reduce(1, :*)                         #=&gt; 151200
# Same using a block
(5..10).inject(1) {|product, n| product * n } #=&gt; 151200</pre>
</div></li>
    <li>在定义二元操作符方法时，将其的参数取名为other。
<div>
<pre>def +(other)
  # body omitted
end</pre>
</div></li>
    <li><code>map</code>优先于<code>collect</code>，<code>find</code>优先于<code>detect</code>，<code>select</code>优先于<code>find_all</code>，<code>reduce</code>优先于<code>inject</code>，<code>size</code>优先于<code>length</code>。以上的规则并不绝定，如果使用后者能提高代码的可读性，那么尽管使用它们。这些对应的方法名（如collect，detect，inject）继承于SmallTalk语言，它们在其它语言中并不是很通用。鼓励使用select而不是find_all是因为select与reject一同使用时很不错，并且它的名字具有很好的自解释性。</li>
</ul>


<h2>注释</h2>


<blockquote>Good code is its own best documentation. As you&#8217;re about to add a comment, ask yourself, &#8220;How can I improve the code so that this comment isn&#8217;t needed?&#8221; Improve the code and then document it to make it even clearer. 
&#8211; Steve McConnell 好的代码在于它有好的文档。当你打算添加一个注释，问问自己，“我该做的是怎样提高代码质量，那么这个注释是不是不需要了？”提高代码并且给他们添加文档使得它更加简洁。
&#8211; Steve McConnell</blockquote>


<ul>
    <li>写出自解释文档代码，然后忽略不工作的这部分。这不是说着玩。</li>
    <li>注释长于一个单词则以大写开始并使用标点。使用一个空格将注释与符号隔开。Use <a href="http://en.wikipedia.org/wiki/Sentence_spacing">one space</a> after periods.</li>
    <li>避免多余的注释。
<div>
<pre># bad
counter += 1 # increments counter by one</pre>
</div></li>
    <li>随时更新注释，没有注释比过期的注释更好。</li>
    <li>不要为糟糕的代码写注释。重构它们，使它们能够“自解释”。(Do or do not - there is no try.)</li>
</ul>


<h2>注解</h2>


<ul>
    <li>注解应该写在紧接相关代码的上方。</li>
    <li>注解关键字后跟一个冒号和空格，然后是描述问题的记录。</li>
    <li>如果需要多行来描述问题，随后的行需要在<code>#</code>后面缩进两个空格。
<div>
<pre>def bar
  # FIXME: This has crashed occasionally since v3.2.1. It may
  #  be related to the BarBazUtil upgrade.
  baz(:quux)
end</pre>
</div></li>
    <li>如果问题相当明显，那么任何文档就多余了，注解也可以（违规的）在行尾而没有任何备注。这种用法不应当在一般情况下使用，也不应该是一个rule。
<div>
<pre>def bar
  sleep 100 # OPTIMIZE
end</pre>
</div></li>
    <li>使用<code>TODO</code>来备注缺失的特性或者在以后添加的功能。</li>
    <li>使用<code>FIXME</code>来备注有问题需要修复的代码。</li>
    <li>使用<code>OPTIMIZE</code>来备注慢的或者低效的可能引起性能问题的代码。</li>
    <li>使用<code>HACK</code>来备注那些使用问题代码的地方可能需要重构。</li>
    <li>使用<code>REVIEW</code>来备注那些需要反复查看确认工作正常的代码。例如：<code>REVIEW: 你确定客户端是怎样正确的完成X的吗？</code></li>
    <li>使用其他自定义的关键字如果认为它是合适的，但是确保在你的项目的<code>README</code>或者类似的地方注明。</li>
</ul>


<h2>类</h2>


<ul>
    <li>在设计类层次的时候确保他们符合<a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov Substitution Principle</a>原则。(译者注: LSP原则大概含义为: 如果一个函数中引用了`父类的实例&#8217;, 则一定可以使用其子类的实例替代, 并且函数的基本功能不变. (虽然功能允许被扩展)) &gt;Liskov替换原则：子类型必须能够替换它们的基类型 &gt; 1. 如果每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换为o2时,程序P的行为没有变化，那么类型T2是类型T1的子类型。 &gt; 2. 换言之，一个软件实体如果使用的是一个基类的话，那么一定适用于其子类，而且它根本不能察觉出基类对象和子类对象的区别。只有衍生类替换基类的同时软件实体的功能没有发生变化，基类才能真正被复用。 &gt; 3. 里氏代换原则由Barbar Liskov(芭芭拉.里氏)提出，是继承复用的基石。 &gt; 4. 一个继承是否符合里氏代换原则，可以判断该继承是否合理（是否隐藏有缺陷）。</li>
    <li>努力是你的类尽可能的健壮<a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID</a>。</li>
    <li>总是为你自己的类提供to_s方法, 用来表现这个类（实例）对象包含的对象.
<div>
<pre>class Person
  attr_reader :first_name, :last_name

  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end

  def to_s
    "#@first_name #@last_name"
  end
end</pre>
</div></li>
    <li>使用<code>attr</code>功能功能成员来定义各个实例变量的访问器或者修改器方法。
<div>
<pre># bad
class Person
  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end

  def first_name
    @first_name
  end

  def last_name
    @last_name
  end
end

# good
class Person
  attr_reader :first_name, :last_name

  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end
end</pre>
</div></li>
    <li>考虑添加工厂方法来提供灵活的方法来创建实际类实例。
<div>
<pre>class Person
  def self.create(potions_hash)
    # body omitted
  end
end</pre>
</div></li>
    <li>鸭子类型（<a href="http://en.wikipedia.org/wiki/Duck_typing">duck-typing</a>）由于继承。
<div>
<pre># bad
class Animal
  # abstract method
  def speak
  end
end

# extend superclass
class Duck &lt; Animal
  def speak
    puts 'Quack! Quack'
  end
end

# extend superclass
class Dog &lt; Animal
  def speak
    puts 'Bau! Bau!'
  end
end

# good
class Duck
  def speak
    puts 'Quack! Quack'
  end
end

class Dog
  def speak
    puts 'Bau! Bau!'
  end
end</pre>
</div></li>
    <li>避免使用类变量（<code>@@</code>）因为他们讨厌的继承习惯（在子类中也可以修改父类的类变量）。
<div>
<pre>class Parent
  @@class_var = 'parent'

  def self.print_class_var
    puts @@class_var
  end
end

class Child &lt; Parent
  @@class_var = 'child'
end

Parent.print_class_var # =&gt; will print "child"</pre>
</div>
正如上例看到的, 所有的子类共享类变量, 并且可以直接修改类变量,此时使用类实例变量是更好的主意.</li>
    <li>根据方法的用途为他们分配合适的可见度( <code>private</code>, <code>protected</code> )，不要让所有的方法都是 <code>public</code> (这是默认设定)。这是 <em>Ruby</em> 不是 *Python*。</li>
    <li><code>public</code>, <code>protected</code>, 和 <code>private</code> 等可见性关键字应该和其（指定）的方法具有相同的缩进。并且不同的可见性关键字之间留一个空格。
<div>
<pre>class SomeClass
  def public_method
    # ...
  end

  private
  def private_method
    # ...
  end
end</pre>
</div></li>
    <li>使用self来定义单例方法. 当代码重构时, 这将使得方法定义代码更加具有灵活性.
<div>
<pre>class TestClass
  # bad
  def TestClass.some_method
    # body omitted
  end

  # good
  def self.some_other_method
    # body ommited
  end

  # 也可以这样方便的定义多个单例方法。
  class &lt;&lt; self
    def first_method
      # body omitted
    end

    def second_method_etc
      # body omitted
    end
  end
end</pre>
</div>
<pre lang="shell"><code>class SingletonTest def size 25 end end test1 = SingletonTest.new test2 = SingletonTest.new def test2.size 10 end test1.size # =&gt; 25 test2.size # =&gt; 10 </code></pre>
本例中，test1 與 test2 屬於同一類別，但 test2 具有重新定義的 size 方法，因此兩者的行為會不一樣。只給予單一物件的方法稱為单例方法 (singleton method)。</li>
</ul>


<h2>异常处理</h2>


<ul>
    <li>不要抑制异常输出。
<div>
<pre>begin
  # an exception occurs here
rescue SomeError
  # the rescue clause does absolutely nothing还没有补救代码
end</pre>
</div></li>
    <li>不要用异常来控制流。
<div>
<pre># bad
begin
  n / d
rescue ZeroDivisionError
  puts "Cannot divide by 0!"
end

# good
if n.zero?
  puts "Cannot divide by 0!"
else
  n / d</pre>
</div></li>
    <li>应该总是避免拦截(最顶级的)Exception异常类.
<div>
<pre># bad 
begin
  # an exception occurs here
rescue
  # exception handling
end

# still bad
begin
  # an exception occurs here
rescue Exception
  # exception handling
end</pre>
</div></li>
    <li>将更具体的异常放在拦截链的上方，否则他们将不会被捕获。
<div>
<pre># bad
begin
  # some code
rescue Exception =&gt; e
  # some handling
rescue StandardError =&gt; e
  # some handling
end

# good
begin
  # some code
rescue StandardError =&gt; e
  # some handling
rescue Exception =&gt; e
  # some handling
end</pre>
</div></li>
    <li>使用ensure语句, 来确保总是执行一些特地的操作.
<div>
<pre>f = File.open("testfile")
begin
  # .. process
rescue
  # .. handle error
ensure
  f.close unless f.nil?
end</pre>
</div></li>
    <li>除非必要, 尽可能使用Ruby标准库中异常类，而不是引入一个新的异常类。(而不是派生自己的异常类)</li>
</ul>


<h2>集合</h2>


<ul>
    <li>总是使用%w的方式来定义字符串数组.(译者注: w表示英文单词word, 而且定义之间千万不能有逗号)
<div>
<pre># bad
STATES = ['draft', 'open', 'closed']

# good
STATES = %w(draft open closed)</pre>
</div></li>
    <li>避免直接引用靠后的数组元素, 这样隐式的之前的元素都被赋值为nil.
<div>
<pre>arr = []
arr[100] = 1 # now you have an array with lots of nils</pre>
</div></li>
    <li>如果要确保元素唯一, 则使用 <code>Set</code> 代替 <code>Array</code> .<code>Set</code> 更适合于无顺序的, 并且元素唯一的集合, 集合具有类似于数组一致性操作以及哈希的快速查找.</li>
    <li>尽可能使用符号代替字符串作为哈希键.
<div>
<pre># bad
hash = { 'one' =&gt; 1, 'two' =&gt; 2, 'three' =&gt; 3 }

# good
hash = { one: 1, two: 2, three: 3 }</pre>
</div></li>
    <li>避免使用易变对象作为哈希键。</li>
    <li>优先使用1.9的新哈希语法。
<div>
<pre># bad
hash = { :one =&gt; 1, :two =&gt; 2, :three =&gt; 3 }

# good
hash = { one: 1, two: 2, three: 3 }</pre>
</div></li>
    <li>记住, 在Ruby1.9中, 哈希的表现不再是无序的. (译者注: Ruby1.9将会记住元素插入的序列)</li>
    <li>当遍历一个集合的同时, 不要修改这个集合。</li>
</ul>


<h2>字符串</h2>


<ul>
    <li>优先使用 <code>字符串插值</code> 来代替 <code>字符串串联</code>。
<div>
<pre># bad
email_with_name = user.name + ' &lt;' + user.email + '&gt;'

# good
email_with_name = "#{user.name} &lt;#{user.email}&gt;"</pre>
</div></li>
    <li>当不需要使用 <code>字符串插值</code> 或某些特殊字符时, 应该优先使用单引号.
<div>
<pre># bad
name = "Bozhidar"

# good
name = 'Bozhidar'</pre>
</div></li>
    <li>当使用字符串插值替换 <code>实例变量</code> 时, 应该省略{}.
<div>
<pre>class Person
  attr_reader :first_name, :last_name

  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end

  # bad
  def to_s
    "#{@first_name} #{@last_name}"
  end

  # good
  def to_s
    "#@first_name #@last_name"
  end
end</pre>
</div></li>
    <li>操作较大的字符串时, 避免使用 <code>String#+</code> , 如果需要修改被操作字符串, 应该总是使用 <code>String#&lt;&lt;</code> 作为代替。就地并列字符串实例变体比 <code>String#+</code> 更快，它创建了多个字符串对象。
<div>
<pre># good and also fast
html = ''
html &lt;&lt; '&lt;h1&gt;Page title&lt;/h1&gt;'

paragraphs.each do |paragraph|
  html &lt;&lt; "&lt;p&gt;#{paragraph}&lt;/p&gt;"
end</pre>
</div></li>
</ul>


<h2>正则表达式</h2>


<ul>
    <li>如果只是需要中查找字符串的 <code>text</code>, 不要使用正则表达式：<code>string['text']</code></li>
    <li>针对简单的结构, 你可以直接使用string[/RE/]的方式来查询.
<div>
<pre>match = string[/regexp/]             # get content of matched regexp
first_group = string[/text(grp)/, 1] # get content of captured group
string[/text (grp)/, 1] = 'replace'  # string =&gt; 'text replace'</pre>
</div></li>
    <li>当无需引用分组内容时, 应该使用(?:RE)代替(RE).
<div>
<pre>/(first|second)/   # bad
/(?:first|second)/ # good</pre>
</div></li>
    <li>避免使用 <code>$1-$9</code> 风格的分组引用, 而应该使用1.9新增的命名分组来代替.
<div>
<pre># bad
/(regexp)/ =~ string
...
process $1

# good
/(?&lt;meaningful_var&gt;regexp)/ =~ string
...
process meaningful_var</pre>
</div></li>
    <li>字符类有以下几个特殊关键字值得注意: <code>^</code>, <code>-</code>, <code>\</code>, <code>]</code>, 所以, 不要在集合中, 转义 <code>.</code> 或者 <code>[]</code> 中的括号, 他们是正常字符.</li>
    <li>注意, <code>^</code> 和 <code>$</code> , 他们匹配行首和行尾, 而不是一个字符串的结尾, 如果你想匹配整个字符串, 用 <code>\A</code> 和 <code>\Z</code>。
<div>
<pre>string = "some injection\nusername"
string[/^username$/]   # matches
string[/\Ausername\Z/] # don't match</pre>
</div></li>
    <li>使用 <code>x</code> 修饰符来匹配复杂的表达式, 这将使得RE更具可读性, 你可以添加一些有用的注释. 注意, 所有空格将被忽略.
<div>
<pre>regexp = %r{
  start         # some text
  \s            # white space char
  (group)       # first group
  (?:alt1|alt2) # some alternation
  end
}x</pre>
</div></li>
    <li><code>sub</code>/<code>gsub</code>也支持哈希以及代码块形式语法, 可用于复杂情形下的替换操作.</li>
</ul>


<h2>百分号和字面值</h2>


<ul>
    <li>多用 <code>%w</code>
<div>
<pre>STATES = %w(draft open closed)</pre>
</div></li>
    <li>定义需要插值和嵌套双引号符号的单行字符串，使用%()的方式.而多行字符串, 尽量使用heredocs格式.
<div>
<pre># bad (不需要插值)
%(&lt;div&gt;Some text&lt;/div&gt;)
# should be '&lt;div&gt;Some text&lt;/div&gt;' # 应该这样写

# bad (没有双引号)
%(This is #{quality} style)
# should be "This is #{quality} style" # 应该这样写

# bad (multiple lines)
%(&lt;div&gt;\n&lt;span&gt;#{exclamation}&lt;/span&gt;\n&lt;/div&gt;)
# should be a heredoc.

# good (插值, 引号, 单行)
%(&lt;tr&gt;&lt;td&gt;#{name}&lt;/td&gt;)</pre>
</div>
Heredoc is a robust way to create string in PHP with more lines but without using quotations. Heredoc 是 php 中不使用引号就可以创建多行字符串的一种强大的方式。

line-oriented string literals (Here document) There&#8217;s a line-oriente form of the string literals that is usually called as <code>here document</code>. Following a <code>&lt;&lt;</code> you can specify a string or an identifier to terminate the string literal, and all lines following the current line up to the terminator are the value of the string. If the terminator is quoted, the type of quotes determines the type of the line-oriented string literal. Notice there must be <strong>no space between <code>&lt;&lt;</code> and the terminator</strong> .

If the - placed before the delimiter, then all leading whitespcae characters (tabs or spaces) are stripped from input lines and the line containing delimiter. This allows here-documents within scripts to be indented in a natural fashion.
<div>
<pre>  print &lt;&lt;EOF
    The price is #{$Price}.
    EOF

  print &lt;&lt;"EOF";            # same as above
The price is #{$Price}.
EOF

  print &lt;&lt;`EOC`         # execute commands
echo hi there
echo lo there
EOC

  print &lt;&lt;"foo", &lt;&lt;"bar"    # you can stack them
I said foo.
foo
I said bar.
bar

  myfunc(&lt;&lt;"THIS", 23, &lt;&lt;'THAT')
Here's a line
or two.
THIS
and here's another.
THAT

  if need_define_foo
    eval &lt;&lt;-EOS         # delimiters can be indented
      def foo
        print "foo\n"
      end
    EOS
  end</pre>
</div></li>
    <li><code>%r</code> 的方式只适合于定义包含多个 <code>/</code> 符号的正则表达式。
<div>
<pre># bad
%r(\s+)

# still bad
%r(^/(.*)$)
# should be /^\/(.*)$/

# good
%r(^/blog/2011/(.*)$)</pre>
</div>
<div>
<pre>irb(main):001:0&gt; string="asdfas.64"
=&gt; "asdfas.64"
irb(main):002:0&gt; string[/^\/(.*)$/]
=&gt; nil
irb(main):003:0&gt; string="/asdfas.64"
=&gt; "/asdfas.64"
irb(main):004:0&gt; string[/^\/(.*)$/]
=&gt; "/asdfas.64"
irb(main):007:0&gt; string="/blog/2011/asdfas.64"
=&gt; "/blog/2011/tmp/asdfas.64"
irb(main):008:0&gt; string[%r(^/blog/2011/(.*)$)]
=&gt; "/blog/2011/tmp/asdfas.64"</pre>
</div></li>
    <li>避免使用<code>%q</code>，<code>%Q</code>， <code>%x</code>， <code>%s</code>,和 <code>%W</code></li>
    <li>优先使用()作为%类语法格式的分隔符.(译者注, 本人很喜欢 <code>%(...)</code>, 不过Programming Ruby中, 显然更喜欢使用%{}的方式)</li>
</ul>


<h2>元编程</h2>


<ul>
    <li>在编写库时，不要乱动核心库。（不要画蛇添足）</li>
</ul>


<h2>杂项</h2>


<ul>
    <li>总是打开Ruby -w开关。</li>
    <li>通常情况下, 尽量避免使用哈希作为方法的 <code>optional</code> 参数. (此时应该考虑这个方法是不是功能太多?)</li>
    <li>避免一个方法内容超过10行代码, 理想情况下, 大多数方法内容应该少于5行.(不算空行)</li>
    <li>尽量避免方法的参数超过三或四个.</li>
    <li>有时候, 必须用到全局方法, 应该增加这些方法到 Kernel 模块，并设置他们可见性关键字为 <code>private</code>。</li>
    <li>尽可能使用类实例变量代替全局变量. (译者注:是类实例变量, 而不是类的实例变量. 汗~~)
<div>
<pre>#bad
$foo_bar = 1

#good
class Foo
  class &lt;&lt; self
    attr_accessor :bar
  end
end

Foo.bar = 1</pre>
</div></li>
    <li>能够用 <code>alias_method</code> 就不要用 <code>alias</code>。</li>
    <li>使用 <code>OptionParser</code> 来解析复杂的命令行选项， 较简单的命令行， <code>-s</code> 参数即可。</li>
    <li>按照功能来编写方法, 当方法名有意义时, 应该避免方法功能被随意的改变。</li>
    <li>避免不需要的元编程。</li>
    <li>除非必要, 避免更改已经定义的方法的参数。</li>
    <li>避免超过三级的代码块嵌套。</li>
    <li>应该持续性的遵守以上指导方针。</li>
    <li>多使用（生活）常识。</li>
</ul>


<h1>Contributing</h1>


<p>Nothing written in this guide is set in stone. It&rsquo;s my desire to work together with everyone interested in Ruby coding style, so that we could ultimately create a resource that will be beneficial to the entire Ruby community.</p>

<p>Feel free to open tickets or send pull requests with improvements. Thanks in advance for your help!</p>

<h1>Spread the Word</h1>


<p>A community-driven style guide is of little use to a community that doesn&rsquo;t know about its existence. Tweet about the guide, share it with your friends and colleagues. Every comment, suggestion or opinion we get makes the guide just a little bit better. And we want to have the best possible guide, don&rsquo;t we?</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/24/railszhong-de-ye-wu-chu-li-active-record-transactions/">rails中的业务处理Active Record Transactions</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-24T22:19:00+08:00" pubdate data-updated="true">Mar 24<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>rails中的业务处理Active Record Transactions</h2>

<p><a href="http://api.rubyonrails.org/classes/ActiveRecord/Transactions.html">Transactions</a> are protective blocks where SQL statements are only permanent if they can all succeed as one atomic action. The classic example is a transfer between two accounts where you can only have a deposit if the withdrawal succeeded and vice versa.</p>

<p><a href="http://api.rubyonrails.org/classes/ActiveRecord/Transactions.html">Transactions</a>是保护行的代码块，用于只有你能够完成所有的元操作才permanent SQL statements（执行sql语句）。经典的例子是一个在两个帐号之间的业务，这里你只能在转账成功后才能有一个deposit存款，反之也是。</p>

<p><a href="http://api.rubyonrails.org/classes/ActiveRecord/Transactions.html">Transactions</a> enforce the integrity of the database and guard the data against program errors or database break-downs. So basically you should use transaction blocks whenever you have a number of statements that must be executed together or not at all.</p>

<p><a href="http://api.rubyonrails.org/classes/ActiveRecord/Transactions.html">Transactions</a> 保障了数据库的有效性，能够防止程序错误或者数据库故障对数据的影响。因此基本上你应该使用<a href="http://api.rubyonrails.org/classes/ActiveRecord/Transactions.html">Transactions</a>代码块无论何时你需要一系列的声明必须在一起执行或者什么都不做。</p>

<p>For example:</p>

<pre data-second_best="[object Object]" data-result="[object Object]">ActiveRecord::Base.transaction do
  david.withdrawal(100)
  mary.deposit(100)
end</pre>


<p>This example will only take money from David and give it to Mary if neither <code>withdrawal</code> nor <code>deposit</code> raise an exception. Exceptions will force a ROLLBACK that returns the database to the state before the transaction began. Be aware, though, that the objects will <em>not</em> have their instance data returned to their pre-transactional state.</p>

<p>这个例子仅仅从David那里转账一些钱给Mary如果汇款或者存款都没有异常抛出。意外情况发生则会强制一个回滚数据库到业务开始的状态。请保持清醒，这样，对象将不会有实例数据回到到它们的每一个业务来源地。</p>

<h2 id="label-Different+Active+Record+classes+in+a+single+transaction">Different Active Record classes in a single transaction</h2>


<p>Though the transaction class method is called on some Active Record class, the objects within the transaction block need not all be instances of that class. This is because transactions are per-database connection, not per-model.</p>

<p>即使transaction类方法被一些的Active Record class调用，在transaction代码块中的对象并不需要所有的实例都是来自那个类。这是因为transaction是基于每个数据连接的而不是每个model。</p>

<p>In this example a <code>balance</code> record is transactionally saved even though <code>transaction</code> is called on the <code>Account</code> class:</p>

<p>在这个例子中余额记录被transactionally保存即使<code>transaction也被Account类调用。</code></p>

<pre data-second_best="[object Object]" data-result="[object Object]">Account.transaction do
  balance.save!
  account.save!
end</pre>


<p>The <code>transaction</code> method is also available as a model instance method. For example, you can also do this:</p>

<p><code>transaction在model实例方法中也是可用的。例如你可以这样做：</code></p>

<pre data-second_best="[object Object]" data-result="[object Object]">balance.transaction do
  balance.save!
  account.save!
end</pre>


<h2 id="label-Transactions+are+not+distributed+across+database+connections"><a href="http://api.rubyonrails.org/classes/ActiveRecord/Transactions.html">Transactions</a> are not distributed across database connections</h2>


<p>A transaction acts on a single database connection. If you have multiple class-specific databases, the transaction will not protect interaction among them. One workaround is to begin a transaction on each class whose models you alter:</p>

<p>一个transaction动作是一个单个的数据库连接。如果你的数据库指定了多个类，transaction将不会保护他们全部的相互影响。一个解决办法是开始一个transaction包含你要改变的model的每一个类：</p>

<pre data-second_best="[object Object]" data-result="[object Object]">Student.transaction do
  Course.transaction do
    course.enroll(student)
    student.units += course.units
  end
end</pre>


<p>This is a poor solution, but fully distributed transactions are beyond the scope of Active Record.</p>

<p>这是一个无赖的办法，但是完整的区域业务超出了Active Record的范围。</p>

<h2 id="label-save+and+destroy+are+automatically+wrapped+in+a+transaction"><code>save</code> and <code>destroy</code> are automatically wrapped in a transaction</h2>


<p>Both <code>save</code> and <code>destroy</code> come wrapped in a transaction that ensures that whatever you do in validations or callbacks will happen under its protected cover. So you can use validations to check for values that the transaction depends on or you can raise exceptions in the callbacks to rollback, including <code>after_*</code> callbacks.</p>

<p>保存和删除都是包装在一个业务中的确保无论你何时做验证或者回调都会在它的保护下。因此你可以使用验证来检查业务中的值在此基础上或者你可以在回调中抛出异常来回滚，包含<code>after_*</code> callbacks。</p>

<p>As a consequence changes to the database are not seen outside your connection until the operation is complete. For example, if you try to update the index of a search engine in <code>after_save</code> the indexer won’t see the updated record. The <code>after_commit</code> callback is the only one that is triggered once the update is committed. See below.</p>

<p>这样有一个后果就是在你的操作完成之前，数据库的改变都不会表现出来（不会突出于你的连接之外）。例如，如果你尝试使用<code>after_save</code>更新一个搜索引擎的索引，索引者将不会发现更新的记录。<code>after_commit回调是仅有的一个</code>它会在一旦更新完成就被触发。看下面。</p>

<h2 id="label-Exception+handling+and+rolling+back">Exception handling and rolling back</h2>


<h2 id="label-Exception+handling+and+rolling+back">Exception handling and rolling back</h2>


<p>Also have in mind that exceptions thrown within a transaction block will be propagated (after triggering the ROLLBACK), so you should be ready to catch those in your application code.</p>

<p>同样也要留心在一个业务代码块中的异常抛出将会被传播（在触发回调之后）。因此你应该准备好在应用程序中抓取这些异常。</p>

<p>One exception is the <code>ActiveRecord::Rollback</code> exception, which will trigger a ROLLBACK when raised, but not be re-raised by the transaction block.</p>

<p><strong>Warning</strong>: one should not catch <code>ActiveRecord::StatementInvalid</code> exceptions inside a transaction block. <code>ActiveRecord::StatementInvalid</code> exceptions indicate that an error occurred at the database level, for example when a unique constraint is violated. On some database systems, such as PostgreSQL, database errors inside a transaction cause the entire transaction to become unusable until it&rsquo;s restarted from the beginning. Here is an example which demonstrates the problem:</p>

<pre data-result="[object Object]"># Suppose that we have a Number model with a unique column called 'i'.
Number.transaction do
  Number.create(:i =&gt; 0)
  begin
    # This will raise a unique constraint error...
    Number.create(:i =&gt; 0)
  rescue ActiveRecord::StatementInvalid
    # ...which we ignore.
  end

  # On PostgreSQL, the transaction is now unusable. The following
  # statement will cause a PostgreSQL error, even though the unique
  # constraint is no longer violated:
  Number.create(:i =&gt; 1)
  # =&gt; "PGError: ERROR:  current transaction is aborted, commands
  #     ignored until end of transaction block"
end</pre>


<p>One should restart the entire transaction if an <code>ActiveRecord::StatementInvalid</code> occurred.</p>

<p>应该重新开始业务如果<code>ActiveRecord::StatementInvalid发生了。</code></p>

<h2 id="label-Nested+transactions">Nested transactions</h2>


<p><code>transaction</code> calls can be nested. By default, this makes all database statements in the nested transaction block become part of the parent transaction. For example, the following behavior may be surprising:</p>

<p><code>transaction可以嵌套调用。默认情况下，这将会将被嵌套的<code>transaction作为其中</code>所有的数据库声明</code>的父业务。</p>

<pre data-result="[object Object]">User.transaction do
  User.create(:username =&gt; 'Kotori')
  User.transaction do
    User.create(:username =&gt; 'Nemu')
    raise ActiveRecord::Rollback
  end
end</pre>


<p>creates both “Kotori” and “Nemu”. Reason is the <code>ActiveRecord::Rollback</code> exception in the nested block does not issue a ROLLBACK. Since these exceptions are captured in transaction blocks, the parent block does not see it and the real transaction is committed.</p>

<p>In order to get a ROLLBACK for the nested transaction you may ask for a real sub-transaction by passing <code>:requires_new =&gt; true</code>. <strong>If anything goes wrong, the database rolls back to the beginning of the sub-transaction without rolling back the parent transaction. 如果有任何错误，数据库将会回滚到子业务的开始状态，并没有回滚父业务。</strong>If we add it to the previous example:</p>

<pre data-result="[object Object]">User.transaction do
  User.create(:username =&gt; 'Kotori')
  User.transaction(:requires_new =&gt; true) do
    User.create(:username =&gt; 'Nemu')
    raise ActiveRecord::Rollback
  end
end</pre>


<p><strong>only “Kotori” is created. (This works on MySQL and PostgreSQL, but not on SQLite3.)</strong></p>

<p><strong>Most databases don’t support true nested transactions.</strong> At the time of writing, the only database that we’re aware of that supports true nested transactions, is MS-SQL. Because of this, Active Record emulates nested transactions by using savepoints on MySQL and PostgreSQL. See <a href="http://dev.mysql.com/doc/refman/5.0/en/savepoint.html">dev.mysql.com/doc/refman/5.0/en/savepoint.html</a> for more information about savepoints.</p>

<h3 id="label-Callbacks"><a href="http://api.rubyonrails.org/classes/ActiveRecord/Callbacks.html">Callbacks</a></h3>


<p>There are two types of callbacks associated with committing and rolling back transactions: <code>after_commit</code> and <code>after_rollback</code>.</p>

<p><code>after_commit</code> callbacks are called on every record saved or destroyed within a transaction immediately after the transaction is committed. <code>after_rollback</code> callbacks are called on every record saved or destroyed within a transaction immediately after the transaction or savepoint is rolled back.</p>

<p>These callbacks are useful for interacting with other systems since you will be guaranteed that the callback is only executed when the database is in a permanent state. For example, <code>after_commit</code> is a good spot to put in a hook to clearing a cache since clearing it from within a transaction could trigger the cache to be regenerated before the database is updated.</p>

<h3 id="label-Caveats">Caveats</h3>


<p>If you’re on MySQL, then do not use DDL operations in nested transactions blocks that are emulated with savepoints. That is, do not execute statements like ‘CREATE TABLE’ inside such blocks. This is because MySQL automatically releases all savepoints upon executing a DDL operation. When <code>transaction</code> is finished and tries to release the savepoint it created earlier, a database error will occur because the savepoint has already been automatically released. The following example demonstrates the problem:</p>

<pre data-result="[object Object]">Model.connection.transaction do                           # BEGIN
  Model.connection.transaction(:requires_new =&gt; true) do  # CREATE SAVEPOINT active_record_1
    Model.connection.create_table(...)                    # active_record_1 now automatically released
  end                                                     # RELEASE savepoint active_record_1
                                                          # ^^^^ BOOM! database error!
end</pre>


<p>Note that “TRUNCATE” is also a MySQL DDL statement!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/21/rubybian-liang/">Ruby变量</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-21T16:51:00+08:00" pubdate data-updated="true">Mar 21<span>st</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>ruby变量</h2>

<p>变量，实例变量，类变量，甚至还有&#8221;常量&#8221;其实都只是对象引用。它们引用对象，但是它们并不是对象本身。因此，它们可以被动态地改变，甚至引用另一种不同类型的对象。</p>

<p>　　因为这一灵活性，所以必须在Ruby中进行一些约定以帮助每个人都知道某个变量正为代码所使用。其实，你已经看到了其中之一（@符号，它意味着这是一个实例变量）。其它的变量，方法和类命名约定列于下表1中。</p>

<p>　　· 局部变量和方法参数以一个小写字母开头。
　　· 方法名字以一个小写字母开头。
　　· 全局变量以一个$开头。
　　· 实例变量以一个@开头。
　　· 类变量以两个@开头。
　　· 常数以一个大写字母开头(它们经常被指定全部大写)。
　　· 类和模块名以一个大写字母开头。</p>

<table width="90%" border="1" cellspacing="0" cellpadding="0" align="center">
<tbody>
<tr>
<td>局部变量</td>
<td>全局变量</td>
<td>实例变量</td>
<td>类变量</td>
<td>常数</td>
<td>类名</td>
<td>方法名</td>
</tr>
<tr>
<td>aVar</td>
<td>$Var</td>
<td>@var</td>
<td>@@var</td>
<td>VAR</td>
<td>MyClass</td>
<td>myMethod</td>
</tr>
<tr>
<td>name</td>
<td>$debug</td>
<td>@lastName</td>
<td>@@interest</td>
<td>PI</td>
<td>Rectangle</td>
<td>area</td>
</tr>
</tbody>
</table>


<p>　　　　　　　　表1.这个表包含了在Ruby编码约定下的相关示例</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/21/ooshe-ji-yuan-ze-zong-jie/">OO设计原则总结</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-21T13:40:00+08:00" pubdate data-updated="true">Mar 21<span>st</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>OO设计原则总结</h2>

<div> <wbr>设计原则是基本的工具，应用这些规则可以使你的代码更加灵活，更容易维护，更容易扩展。</wbr></div>


<div>基本设计原则</div>


<div><strong>封装变化（</strong><span style="font-family: Arial, Helvetica, sans-serif; color: #424a5e;">Encapsulate what varies</span><strong>）</strong></div>


<div><strong>面向接口编程而非实现(</strong>code to an interface rather than to an implementation<strong>)</strong></div>


<div><strong>优先使用组合而非继承(</strong>favor Composition over inheritance<strong>)</strong></div>


<div><strong>SRP(S</strong>ingle responsibility Principle<strong>) <wbr></wbr></strong></div>


<div><strong> <wbr>  <wbr></wbr></wbr></strong> <span style="color: #ff0000;">单一职责</span>。系统中的每一个对象都应该只有1个单独的职责，而所有对象所关注的就是自身职责的完成。</div>


<div> <wbr>  <wbr> 每一个职责都是一个设计的变因，需求变化的时候，需求变化反映为类的职责的变化。当你系统里的对象都只有一个变化的原因时，你就已经很好的遵循了SRP原则了。<span style="color: #ff0000;">如果一个类承担了过多的职责，就等于把这些职责耦合在一起了。一个职责的变化就可能消弱或者抑制这个类其它的职责的能力。这种设计会导致脆弱的设计。</span>当发生变化时，设计会遭到意想不到的破坏。</wbr></wbr></div>


<div> <wbr>  <wbr> SRP让这个系统更容易管理和维护，因为不是所有的问题都耦合在一起。</wbr></wbr></div>


<div> <wbr>  <wbr> 内聚（Cohesion）其实是SRP原则的另外一个名字。你写了高内聚的软件其实就是很好的应用了SRP原则。 <wbr></wbr></wbr></wbr></div>


<div><strong>DRY(</strong>Don&#8217;t repeat yourself Principle<strong>)</strong></div>


<div><strong> <wbr>  <wbr></wbr></wbr></strong> <span style="color: #ff0000;">不要重复自己的工作</span>。通过抽取公共部分放置在一个地方来避免重复的代码或功能实现。</div>


<div> <wbr>  <wbr> DRY确保women代码容易维护和复用。确保每一个需求和功能在你的系统中只实现一次，否则就存在浪费！系统的用例不存在交集，所以我们的代码更不应该重复。从这个角度看DRY就不只是在说代码了。DRY关注的是系统内的信息和行为都放在一个单一的，明显的位置。</wbr></wbr></div>


<div> <wbr>  <wbr> <span style="color: #ff0000;">DRY原则：如何对系统职能进行良好的分割！职责清晰的界限一定程度上保证了代码的单一性。</span></wbr></wbr></div>


<div> <wbr>  <wbr> <wbr></wbr></wbr></wbr></div>


<div><strong>OCP(</strong>Open-Close Principle<strong>)</strong></div>


<div><strong> <wbr>  <wbr></wbr></wbr></strong> <span style="color: #ff0000;">开闭原则</span><span style="color: #ff0000;">。</span>OCP关注的是灵活性，改动是通过增加代码进行的，而不是改动现有的代码。</div>


<div> <wbr>  <wbr> OCP的应用限定在可能会发生的变化上，通过创建抽象来隔离以后发生的同类变化。</wbr></wbr></div>


<div> <wbr>  <wbr> OCP传递这样一个思想：<span style="color: #9dbb61;">一旦你写出来可以工作的代码，就要努力保证这段代码可以一直工作。这就成了你的编码的一个底线。一旦我们的代码质量到了一个水平，我们就要尽最大努力保证代码质量不回退。这样就要求我们面对一个问题的时候不会使用凑活的方法来解决，或者说放任自流的方式来解决一个问题</span>（比如：代码添加了无数对特定数据的处理，特化的代码越来越多，代码意图开始含糊不清，这就开始质量退化了。）</wbr></wbr></div>


<div> <wbr>  <wbr> OCP背后的机制：封装和抽象。封闭是建立在抽象的基础上的，使用抽象获得显示的封闭。继承是OCP最简单的例子。除了子类化和方法重载我们还有一些更优雅的方法来实现比如组合。</wbr></wbr></div>


<div> <wbr>  <wbr> 那么如何在不改变源代码（关闭修改）的情况下更改它的行为呢？答案就是抽象。</wbr></wbr></div>


<div> <wbr>  <wbr> 正确的做法就是<span style="color: #ff0000;">开发人员仅对频繁变化的部分做出抽象。拒绝不成熟的抽象，这和抽象本身一样的重要</span>。</wbr></wbr></div>


<div> <wbr>  <wbr> OCP是OOD很多说法的核心，如果这个原则有效的应用，我们可以获得更强的可维护性 可重用性 灵活性 健壮性。。然而LSP是OCP成为可能的主要原则之一。</wbr></wbr></div>


<div><strong>LSP(Liskov</strong> <wbr>substitution<strong> <wbr></wbr></strong>Principle<strong>)</strong></wbr></div>


<div><span style="color: #ff0000;">子类必须能够替换基类</span>。LSP关注的是怎样良好的使用继承。必须清楚是使用一个Method还是要扩展它，但是绝对不是改变它。</div>


<div> <wbr>  <wbr>  <wbr>  <wbr> LSP让我们得出一个重要的结论：一个模型如果孤立的看，并不具有真正意义的有效性，模型的有效性只能通过它的客户程序来表现。必须根据设计的使用者做出的合理假设来审视它。而假设是难以预测的，知道设计臭味出现的时候才处理他们。</wbr></wbr></wbr></wbr></div>


<div><strong>DIP(</strong>Dependency-Inversion Principle<strong>)</strong></div>


<div><strong><span style="color: #ff0000;">依赖反转/依赖倒置</span>。</strong>高层模块不依赖底层模块 两者都应只依赖于抽象。</div>


<div> <wbr>  <wbr> 抽象不依赖于细节， 而细节依赖于抽象。</wbr></wbr></div>


<div> <wbr>  <wbr> 高层模块：包含了应用程序中重要的策略选择和业务模型。这些高层模块使其所在的应用程序区别于其他。</wbr></wbr></div>


<div><span style="color: #b5a5d5;">框架设计的核心原则</span>： 如果高层模块依赖底层模块，那么在不同的上下文中重用高层模块会变得十分困难。然而，如果高层模块不依赖于底层模块，那么高层模块就可以非常容易的被重用。</div>


<div> <wbr>  <wbr> 这里的倒置不仅仅指依赖关系的倒置同时也是接口所有权的倒置。</wbr></wbr></div>


<div> <wbr>  <wbr>Hollywood原则： Don&#8217;t call us。 we will call you. 底层模块实现了在高层模块声明并被高层模块调用的接口。</wbr></wbr></div>


<div><strong> <wbr>  <wbr></wbr></wbr></strong>DIP的简单的启发规则：依赖于抽象。程序汇总所有的依赖都应依赖于抽象类或接口。</div>


<div><strong> <wbr>  <wbr></wbr></wbr></strong>如果一个类很稳定，那么依赖于它不会造成伤害。然而我们自己的具体类大多是不稳定的，通过把他们隐藏在抽象接口后面可以隔离不稳定性。</div>


<div><strong> <wbr>  <wbr></wbr></wbr></strong></div>


<div><strong> <wbr>  <wbr>依赖倒置可以应用于任何一个类向另一个类发送消息的地方。。。（还不是很理解）</wbr></wbr></strong></div>


<div><strong> <wbr>  <wbr></wbr></wbr></strong>依赖倒置原则是实现许多面向对象技术多宣称的好处的基本底层机制，是面向对象的标志所在。 <strong> <wbr> <wbr></wbr></wbr></strong></div>


<div><strong>
</strong></div>


<div><strong>ISP(</strong>Interface Segregation Principle<strong>)</strong></div>


<div><strong><span style="color: #ff0000;">接口隔离原则</span>。</strong></div>


<div>使用多个专门的接口比使用一个单一的接口总要好：从一个客户类的角度来讲，一个类对另外一个类的依赖性应当是建立在最小的接口上。</div>


<div>如果接口不是高内聚的，一个接口可以分成N组方法，那么这个接口就需要使用ISP来处理一下了~~。</div>


<div> <wbr>  <wbr>  <wbr>  <wbr> 一个接口中包含了太多的行为时候，导致他们的客户程序之间产生不正常的依赖关系，我们要做的就是分离接口，实现解耦。使用了ISP后客户程序看到的是多个内聚的接口。</wbr></wbr></wbr></wbr></div>


<p>&nbsp;</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/20/jin-jie-shi-yong-facade-pattern-qu-dai-model-callbacks-by-xdite/">[進階]使用 Facade Pattern 取代 Model Callbacks by Xdite</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-20T15:24:00+08:00" pubdate data-updated="true">Mar 20<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>[進階]使用 Facade Pattern 取代 Model Callbacks by xdite</h2>

<h2>What is “callbacks”?</h2>


<p>Rails 的 ActiveRecord 提供了相當方便的 callbacks，能讓開發者在寫 Controller 時，能夠寫出更加 DRY 的程式碼：</p>

<ul>
    <li>before_crearte</li>
    <li>before_save</li>
    <li>after_create</li>
    <li>after_save</li>
    <li>…</li>
</ul>


<p>在從前，在 Controller 裡面想要再 object 儲存之後 do_something，直觀的思路會是這樣：</p>

<p>class PostController
  def create
    @post = Post.new(params[:post])
    @post.save
    @post.do_something
    redirect_to posts_path
  end
end </p>

<p>當時的最佳模式：通常是建議開發者改用 callbacks 或者是 Observer 模式實作。避免 controller 的髒亂。</p>

<ul>
    <li>callbacks : after_create</li>
</ul>


<p>或者是使用 Observer</p>

<p>class PostController &lt; ApplicationController
  def create
    @post = Post.new(params[:post])
    @post.save
    redirect_to posts_path
  end
end
class PostObserver &lt; ActiveRecord::Observer
  def after_create(post)
    post.do_something
  end
end
class Post &lt; ActiveRecord::Base
  protected
  def do_something
  end
end</p>

<h2>使用 callbacks 所產生的問題</h2>


<p>callbacks 雖然很方便，但也產生一些其他的問題。若這個 do_something 是很輕量的 db update，那這個問題還好。但如果是很 heavy 的 hit_3rd_party_api 呢？</p>

<p>在幾個情形下，開發者會遇到不小的麻煩。</p>

<ul>
    <li>Model 測試：每次在測試時都會被這個 3rd_party_api 整到，因為外部通訊很慢。</li>
    <li>do_something_api 是很 heavy 的操作：每次寫測試還是會被很慢的 db query 整到。</li>
    <li>do_something_api 是很輕微的 update：但是綁定 after_save 操作，在要掃描資料庫，做大規模的某欄位修改時，會不小心觸發到不希望引發的 callbacks，造成不必要的效能問題。</li>
</ul>


<p>當然，開發者還是可以用其他招數去閃開：</p>

<p>比如說若綁定 after_save 。</p>

<p>可以在 do_somehting 內加入對 dirty object 的偵測，避免被觸發：</p>

<p> def do_somthing
  # 資料存在，且變動的欄位包括 content
  if presisited? &amp;&amp; changed.include?(&ldquo;content&rdquo;)
    the_real_thing
  end
 end</p>

<p> 但這一招並不算理想，原因有幾：</p>

<ol>
    <li>每次儲存還是需要被掃描一次，可能有效能問題。</li>
    <li>寫測試時還是會呼叫到可能不需要引發的 do_somehting。</li>
    <li>if xxx ＆＆ yyy 這個 condiction chain 可能會無限延伸下去。</li>
</ol>


<p> Facade Pattern</p>

<p>那麼要怎樣才能解決這個問題呢？其實我們應該用 Facade Pattern 解決這個問題。</p>

<p>設計模式裡面有一招 Facade Pattern，這一招其實是沒有被寫進 <a href="http://designpatternsinruby.com/">Design Pattern in Ruby</a> 中的。Russ Olson 有寫了<a href="http://designpatternsinruby.com/section02/facade.html">一篇文章</a>解釋沒有收錄的原因：因為在 Ruby 中，這一招太簡單太直觀，所以不想收錄 XDDD。但他還是在網站上提供當時寫的草稿，供人參考。</p>

<h3>What is Facade Pattern?</h3>


<p>Facade Pattern 的目的是「將複雜的介面簡化，將複雜與瑣碎的步驟封裝起來，對外開放簡單的介面，讓客戶端能夠藉由呼叫簡單的介面而完成原本複雜的程式演算。」（<a href="http://www.dotblogs.com.tw/jameswu/archive/2008/06/26/4382.aspx">來源</a>）</p>

<p>延伸閱讀: <a href="http://www.cnblogs.com/oomusou/archive/2007/04/24/725714.html">(原創) 我的Design Pattern之旅[5]：Facade Pattern (OO) (Design Pattern) (C/C++)</a></p>

<h3>實際舉例：</h3>


<p>在上述的例子中，其實 do_something 有可能只會在 PostController 用到，而非所有的 model 操作都「需要」用到。所以我們 <strong>不應該將 do_somehting 丟進 callbacks（等於全域觸發），再一一寫 case 去閃避執行</strong></p>

<p>與其寫在 callbacks 裡。我們更應該寫的是一個 Service Class 將這一系列複雜昂貴的行為包裝起來，以簡單的介面執行。
class PostController &lt; ApplicationController
  def create
  CreatePostService(params[:post])
  redirect_to posts_path
  end
 end
class CreatePostService
  def self.create(params)
    post = Post.new(params[:post])
    post.save
    post.do_something_a
    post.do_something_b
    post.do_something_c
  end
end  而在寫測試，只需要對 PostCreateService 這個商業邏輯 class 寫測試即可。而 PostController 和 Post Model 就不會被殃及到。</p>

<h2>小結</h2>


<p>不少開發者討厭測試的原因，不只是「因為」寫測試很麻煩的原因，「跑一輪測試超級久」也是讓大家很不爽的主因之一。</p>

<p>其實不是這些測試框架寫的爛造成「寫測試很麻煩」、「執行測試超級久」。而是另有其他因素。</p>

<p>許多資深開發者逐漸意識到，真正的主因是在於目前 Rails 的 model 的設計，耦合度太高了。只要沾到 db 就慢，偏偏 db 是世界的中心。只是測某些邏輯，搞到不小心觸發其他不需要測的東西。</p>

<p>ActiveRecord 的問題在於，讓開發者太誤以為 ORM = model。其實開發者真正要寫的測試應該是對商業邏輯的測試，不是對 db 進行測試。</p>

<p>所以才會出現了用 Facade Pattern 取代 callbacks 的手法。</p>

<h2>其他</h2>


<p>MVC 其實有其不足的部份。坦白說，Rails 也不是真正的 MVC，而是 <a href="http://andrzejonsoftware.blogspot.com/2011/09/rails-is-not-mvc.html">Model2</a></p>

<p>目前 MVC 其實是不足的，演化下來，開發者會發現 User class 裡面會開始出現這些東西：</p>

<ul>
    <li>current_user.buy_book(book)</li>
    <li>current_user.add_creadit_point(point)</li>
</ul>


<p>這屬於 User 裡面應該放的 method 嗎？well，你也可以說適合，也可以說不適合。</p>

<p>適合的原因是：其實你也不知道應該放哪裡，這好像是 User 執行的事，跟他有關，那就放這裡好了！不然也不知道要擺哪裡。</p>

<p>不適合的原因是：這是一個「商業購買行為」。不是所有人都會購物啊。這應該是一個商業購買邏輯。但是….也不知道要放在哪啊。</p>

<p>一直到最近，James Copelin 提出了：<a href="http://en.wikipedia.org/wiki/Data,_Context,_and_Interaction">DCI</a> 去補充了現有的 MVC 的不足，才算勉強解決了目前浮現的這些問題。</p>

<p>DCI ，與本篇談到的 Facade Pattern 算是頗類似的手法。</p>

<p>有關於 DCI ( Data, Context, Interaction ) 的文章，我會在之後發表。我同時也推薦各位去看這方面的主題。這個方向應該會是 Rails 專案設計上未來演化的方向之一。</p>

<p>&nbsp;</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/20/python-ruby-geek-by-djangoshe-qu-and-ruby-china/">Python Ruby Geek by Django社区and Ruby-china</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-20T13:48:00+08:00" pubdate data-updated="true">Mar 20<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>python ruby geek by django社区and ruby-china</h2>

<p style="text-align: left;">by ruby-china 由 <a href="http://ruby-china.org/users/gaicitadie" data-name="盖茨他爹">gaicitadie</a> 在 <a href="http://ruby-china.org/topics/node27">瞎扯淡</a> 节点</p>




<div>
<p style="text-align: left;">统计一个字符串在另一个字符串中出现的次数，python只需要一个count方法：</p>

<div>
<pre>&gt;&gt;&gt; '11ab1111ab111ac11111'.count('ab') 2</pre>
huacnlee 1楼, 于24小时前回复 irb&gt; &#8216;11ab1111ab111ac11111&#8217;.scan(&#8220;ab&#8221;).count
2
ywencn 2楼, 于24小时前回复 1.9.2p290 :001 &gt;  &#8216;11ab1111ab111ac11111&#8217;.count(&#8216;ab&#8217;)
 =&gt; 5
楼主想表达什么？

ywencn 3楼, 于24小时前回复 哎呀。。。怎么python和ruby的count还不一样，哈哈

huacnlee 4楼, 于24小时前回复 Ruby 的 &#8220;&#8221;.count 统计的是后面所有的字符

dreamrise 5楼, 于24小时前回复 貌似_who还写过一个python与ruby转换的程序？

gaicitadie 6楼, 于23小时前回复 奥运奖牌榜：
国家 金牌数 银牌数 铜牌数
china 37 26 11
usa 30 22 50
russia 30 33 20

中国习惯上先按金牌数排名，金牌数一样的按银牌数再排，如果银牌数再一样就按铜牌数排：

&gt;&gt;&gt; sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:(-x[1],-x[2],-x[3]))
[(&#8216;china&#8217;, 37, 26, 11), (&#8216;russia&#8217;, 30, 33, 20), (&#8216;usa&#8217;, 30, 22, 50)]
美国习惯上金牌银牌铜牌都是奖牌，所以按奖牌总数排序：

&gt;&gt;&gt; sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:-(x[1]+x[2]+x[3]))
[(&#8216;usa&#8217;, 30, 22, 50), (&#8216;russia&#8217;, 30, 33, 20), (&#8216;china&#8217;, 37, 26, 11)]
python的排序达到了类似SQL查询的能力，只需要告诉它排序的条件就可以了，python为数据而生

gaicitadie 7楼, 于23小时前回复 上面的例子是python模拟SQL的order by功能，下面的例子用python模拟SQL的where条件查询

统计金牌数超过35的国家：

&gt;&gt;&gt; [x for x in [(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)] if x[1]&gt;35]
[(&#8216;china&#8217;, 37, 26, 11)]
统计奖牌总数超过100的国家：

&gt;&gt;&gt; [x for x in [(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)] if x[1]+x[2]+x[3]&gt;100]
[(&#8216;usa&#8217;, 30, 22, 50)]
huyong36 8楼, 于23小时前回复 @gaicitadie ruby是

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].select{|x| x[1] &gt; 35}
[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].select{|x| x[1] + x[2] + x[3] &gt; 100}
quakewang 9楼, 于23小时前回复 #6楼 @gaicitadie
order by 的ruby代码

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].sort_by{|m| [-m[1], -m[2], -m[3]]}
[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].sort_by{|m| -(m[1] + m[2] + m[3])]}
skandhas 10楼, 于23小时前回复 从楼主的例子直接翻译到Ruby
1 中国习惯上先按金牌数排名，金牌数一样的按银牌数再排，如果银牌数再一样就按铜牌数排：

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].sort_by{|x| [-x[1],-x[2],-x[3]]}
2 美国习惯上金牌银牌铜牌都是奖牌，所以按奖牌总数排序：

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].sort_by{|x| -(x[1]+x[2]+x[3])}
3 统计金牌数超过35的国家：

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].select{|x| x[1] &gt;35}
4 统计奖牌总数超过100的国家：

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].select{|x| x[1]+x[2]+x[3] &gt; 100}
这两个语言都挺类似，我觉得ruby的select更直观。

另 楼主这个帖子想表达什么？没看出什么来。如果说只通过sorted就说明python是为数据而生的话，那ruby不也是吗。哈哈

daqing 11楼, 于23小时前回复 我来写个Ruby版本的。

第一个，奖牌排序:

data = [[:china, 27, 26, 11], [:usa, 20, 22, 50], [:russia, 30, 33, 20]]

data.sort_by { |x| [-x[1], -x[2], -x[3]] } # 中国排序方法，按金/银/铜牌数
data.sort_by { |x| -(x[1] + x[2] + x[3]) } # 美国排序方法，按奖牌总数
第二个，奖牌统计:

data.select { |x| x[1] &gt; 35 } # 金牌数超过35的国家
data.select { |x| x[1] + x[2] + x[3] &gt; 100 } # 奖牌总数超过100的国家
哪个更简洁，一目了然了吧。

daqing 12楼, 于23小时前回复 原来大家都在回复。。等我写出来才发现。

daqing 13楼, 于23小时前回复 #10楼 @skandhas 看了你的方法，才想到，select是更直接的做法。collect方法会包含nil值。

reus 14楼, 于23小时前回复 Why I Hate Advocacy
<a href="http://www.perl.com/pub/2000/12/advocacy.html">http://www.perl.com/pub/2000/12/advocacy.html</a>

gaicitadie 15楼, 于23小时前回复 总统选举投票，初步唱票记录：

[&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
根据唱票记录统计每人的票数并按从多到少排序

&gt;&gt;&gt; l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
&gt;&gt;&gt; sorted(set([(i, l.count(i)) for i in l]), key=lambda x:-x[1])
[(&#8216;Jim&#8217;, 4), (&#8216;bush&#8217;, 2), (&#8216;obama&#8217;, 1)]
clearJiang 16楼, 于23小时前回复 #15楼 @gaicitadie 不如直接用collections.Counter

gaicitadie 17楼, 于23小时前回复 #16楼 @clearJiang 低版本没有collections

daqing 18楼, 于23小时前回复 总统选举投票

l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
l.uniq.collect { |x| [x, l.count(x)] }
=&gt; [[&#8220;Jim&#8221;, 4], [&#8220;bush&#8221;, 2], [&#8220;obama&#8221;, 1]]
skandhas 19楼, 于22小时前回复 #15楼 @gaicitadie
根据唱票记录统计每人的票数并按从多到少排序:

l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
l.group_by{|i| i}.map{|k,v| [k,v.length] }
quakewang 20楼, 于22小时前回复 python要和ruby比 文件、字符操作或者数组、Hash操作的便利性绝对完败，要砸场还不如在性能上一棍子打死ruby。

bony 21楼, 于22小时前回复 这样的帖子应该多一点。长知识。@skandhas cool.

quakewang 22楼, 于22小时前回复 #15楼 @gaicitadie

[&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;].inject(Hash.new(0)) {|h, e| h[e] += 1; h}.sort_by{|e| -e[1]}
daqing 23楼, 于22小时前回复 说实话，Python的lambda匿名函数，跟Ruby的Block相比，从书写上就败了。

gaicitadie 24楼, 于22小时前回复 随机设置验证码的4个字符(不包括图片处理部分)

&gt;&gt;&gt; import random
&gt;&gt;&gt; s = &#8216;ABCDEFGHIJKLMNPRSTUVWXYZ&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;EXSG&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;TGYN&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;MEYP&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;TGIF&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;JDWF&#8217;
quakewang 25楼, 于22小时前回复 #24楼 @gaicitadie

(&#8216;A&#8217;..&#8217;Z&#8217;).to_a.sample(4).join
reus 26楼, 于22小时前回复 #15楼 @gaicitadie 你这个算法是O(n ^ 2)的，应该用reduce

def stat(acc, x):
  acc.setdefault(x, 0)
  acc[x] += 1
  return acc
sorted(reduce(stat,
  [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;], {}).iteritems(),
    key = lambda x: -x[1])
huyong36 27楼, 于22小时前回复 @skandhas cool,加上个排序。

gaicitadie 28楼, 于22小时前回复 #26楼 @reus reduce不如列表解析快，虽然list.count会重复统计

skandhas 29楼, 于22小时前回复 #27楼 @huyong36
对，是忘了排序

l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
l.group_by{|i| i}.map{|k,v| [k,v.length] }.sort_by{|name,count| -count }
huacnlee 30楼, 于22小时前回复 风格不同而已，用起来都是一样方便。这个就是让我喜欢 Python 和 Ruby 的原因之一。

reus 31楼, 于22小时前回复 #28楼 @gaicitadie
就是慢在count调用上，for i in l遍历数组，且每个元素又再count遍历一次，O(n ^ 2)
reduce只需要遍历一次，O(n)
不信可以测试下

huyong36 32楼, 于22小时前回复 这帖应该是捧场帖,我喜欢这样的学习。

raecoo 33楼, 于22小时前回复 受用

hysios 34楼, 于21小时前回复 •字符串查找
# python
&gt;&gt;&gt; &#8216;11ab1111ab111ac11111&#8217;.count(&#8216;ab&#8217;)
2
# Ruby
ruby-1.9.2-p290 &gt;   &#8216;11ab111123ab111ac11111&#8217;.count &#8216;ab&#8217;, &#8216;b&#8217;
2
hysios 35楼, 于21小时前回复 •奖牌排序
# python
&gt;&gt;&gt; sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:(-x[1],-x[2],-x[3]))
[(&#8216;china&#8217;, 37, 26, 11), (&#8216;russia&#8217;, 30, 33, 20), (&#8216;usa&#8217;, 30, 22, 50)]
# ruby
ruby-1.9.2-p290 &gt; [[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50],[&#8216;russia&#8217;,30,33,20]].sort_by {|name,j,y,t| [-j,-y,-t] }
 =&gt; [[&#8220;china&#8221;, 37, 26, 11], [&#8220;russia&#8221;, 30, 33, 20], [&#8220;usa&#8221;, 30, 22, 50]]
hysios 36楼, 于21小时前回复 •奖牌统计
# python
&gt;&gt;&gt; sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:-(x[1]+x[2]+x[3]))
[(&#8216;usa&#8217;, 30, 22, 50), (&#8216;russia&#8217;, 30, 33, 20), (&#8216;china&#8217;, 37, 26, 11)]
# ruby
ruby-1.9.2-p290 &gt; [[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50],[&#8216;russia&#8217;,30,33,20]].sort_by {|name,j,y,t| [-j + -y + -t] }
 =&gt; [[&#8220;usa&#8221;, 30, 22, 50], [&#8220;russia&#8221;, 30, 33, 20], [&#8220;china&#8221;, 37, 26, 11]]
kfll 37楼, 于21小时前回复 捧场..
js:

&#8216;11ab1111ab111ac11111&#8217;.match(/ab/g).length;
&#8216;11ab1111ab111ac11111&#8217;.split(&#8216;ab&#8217;).length - 1;
中式排名：

[[37, 26, 11], [30, 22, 50], [30, 33, 20]].sort().reverse();
hysios 38楼, 于21小时前回复 总统选举投票，初步唱票记录：

# ruby
&gt;&gt;&gt; l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
&gt;&gt;&gt; sorted(set([(i, l.count(i)) for i in l]), key=lambda x:-x[1])
[(&#8216;Jim&#8217;, 4), (&#8216;bush&#8217;, 2), (&#8216;obama&#8217;, 1)]
# ruby
ruby-1.9.2-p290 &gt;  [&#8216;bush&#8217;,&#8217;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;].each_with_object({}) {|name,s| s[name] = s.fetch(name,0) + 1 }.sort
 =&gt; [[&#8220;Jim&#8221;, 4], [&#8220;bush&#8221;, 3], [&#8220;obama&#8221;, 1]]
huyong36 39楼, 于21小时前回复 #34楼 @hysios

&#8216;11ab111123ab111ac11111&#8217;.count &#8216;ab&#8217;, &#8216;b&#8217;
这样不对吧&#8230;这样只是找出来字符串里出现b的次数。

irb(main):106:0&gt; &#8216;11ab111123ab111ac11111b&#8217;.count &#8216;ab&#8217;, &#8216;b&#8217;
=&gt; 3
hysios 40楼, 于21小时前回复 @huyong36 thx count是没办法实现的, 别的方法也不错

huyong36 41楼, 于20小时前回复 #40楼 @hysios 恩,请教

irb(main):115:0&gt; &#8216;11ab111123ab111c11111&#8217;.count  &#8216;a&#8217;
=&gt; 2
irb(main):114:0&gt; &#8216;11ab111123ab111c11111&#8217;.count  &#8216;ab&#8217;
=&gt; 4
字符可以统计,为什么字符串不能。。

jhjguxin 42楼, 于20小时前回复 @huyong36
count([other_str]+) → fixnum click to toggle source
Each other_str parameter defines a set of characters to count. The intersection of these sets defines the characters to count in str. Any other_str that starts with a caret (^) is negated. The sequence c1–c2 means all characters between c1 and c2.

Guest 43楼, 于20小时前回复 gaicitadie = [[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].tap do |man|
  def man.make_self(&amp;process); process.call self; end
  def man.become_egghead
    `python -c &#8220;print( sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:(-x[1],-x[2],-x[3])) )&#8221;`
  end
  def man.glow_up
    dont_be_shy = true
    unless self.respond_to? :more_elegant, dont_be_shy
      def self.more_elegant
        self.sort_by { |country, glods, silvers, bronzes| [-glods,-silvers,-bronzes] }
      end
    end
    if self.respond_to? :become_egghead
      class &lt;&lt; self; remove_method :become_egghead; end
    end
    self
  end
end
gaicitadie.make_self &amp;:become_egghead
gaicitadie.glow_up.make_self &amp;:more_elegant
geekontheway 44楼, 于20小时前回复 #41楼 @huyong36 ruby的count 统计的是字符的数量 所以&#8217;11ab111123ab111c11111&#8217;.count &#8216;ab&#8217;等同于&#8217;11ab111123ab111c11111&#8217;.count &#8216;a&#8217; + &#8216;11ab111123ab111c11111&#8217;.count &#8216;b&#8217;

jhjguxin 45楼, 于20小时前回复 简而言之就是 取每一个字符的count的交集

huyong36 46楼, 于20小时前回复 @geekontheway @jhjguxin 3Q&#8230;

hysios 47楼, 于20小时前回复 #41楼 @huyong36 count 是统计所有的字符,并不会把参数当成字符串处理

FenRagwort 48楼, 于17小时前回复 合并两个字典/哈希，重复的项目，两个值相加

hash1.merge(hash2) {|dupkey,val1,val2| val1 + val2 }
楼主来个Python的写法？

hhuai 49楼, 于16小时前回复 method_missing, 楼主来个？？

gaicitadie 50楼, 于14小时前回复 #48楼 @FenRagwort ，这个暂时只想到了普通方法

for k,v in hash2.items():
    if k in hash1:
        hash1[k] += v
    else:
        hash1.setdefault(k,v)
zw963 51楼, 于12小时前回复 #19楼 @skandhas

的确酷, 不说说实在的. group_by用来做这个, 真是有点大才小用了.

reus 52楼, 于12小时前回复 #49楼 @hhuai

class Foo:
  def __getattr__(self, name):
    def _foo(*arg, **kwargs):
      return self.method_missing(name, *arg, **kwargs)
    return _foo

  def method_missing(self, name, *args, **kwargs):
    print name, args, kwargs

a = Foo()
a.foo(&#8216;bar&#8217;, baz = &#8216;baz&#8217;)

&nbsp;

huacnlee 1楼, 于24小时前回复 irb&gt; &#8216;11ab1111ab111ac11111&#8217;.scan(&#8220;ab&#8221;).count
2
ywencn 2楼, 于24小时前回复 1.9.2p290 :001 &gt;  &#8216;11ab1111ab111ac11111&#8217;.count(&#8216;ab&#8217;)
 =&gt; 5
楼主想表达什么？

ywencn 3楼, 于24小时前回复 哎呀。。。怎么python和ruby的count还不一样，哈哈

huacnlee 4楼, 于24小时前回复 Ruby 的 &#8220;&#8221;.count 统计的是后面所有的字符

dreamrise 5楼, 于24小时前回复 貌似_who还写过一个python与ruby转换的程序？

gaicitadie 6楼, 于23小时前回复 奥运奖牌榜：
国家 金牌数 银牌数 铜牌数
china 37 26 11
usa 30 22 50
russia 30 33 20

中国习惯上先按金牌数排名，金牌数一样的按银牌数再排，如果银牌数再一样就按铜牌数排：

&gt;&gt;&gt; sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:(-x[1],-x[2],-x[3]))
[(&#8216;china&#8217;, 37, 26, 11), (&#8216;russia&#8217;, 30, 33, 20), (&#8216;usa&#8217;, 30, 22, 50)]
美国习惯上金牌银牌铜牌都是奖牌，所以按奖牌总数排序：

&gt;&gt;&gt; sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:-(x[1]+x[2]+x[3]))
[(&#8216;usa&#8217;, 30, 22, 50), (&#8216;russia&#8217;, 30, 33, 20), (&#8216;china&#8217;, 37, 26, 11)]
python的排序达到了类似SQL查询的能力，只需要告诉它排序的条件就可以了，python为数据而生

gaicitadie 7楼, 于23小时前回复 上面的例子是python模拟SQL的order by功能，下面的例子用python模拟SQL的where条件查询

统计金牌数超过35的国家：

&gt;&gt;&gt; [x for x in [(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)] if x[1]&gt;35]
[(&#8216;china&#8217;, 37, 26, 11)]
统计奖牌总数超过100的国家：

&gt;&gt;&gt; [x for x in [(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)] if x[1]+x[2]+x[3]&gt;100]
[(&#8216;usa&#8217;, 30, 22, 50)]
huyong36 8楼, 于23小时前回复 @gaicitadie ruby是

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].select{|x| x[1] &gt; 35}
[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].select{|x| x[1] + x[2] + x[3] &gt; 100}
quakewang 9楼, 于23小时前回复 #6楼 @gaicitadie
order by 的ruby代码

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].sort_by{|m| [-m[1], -m[2], -m[3]]}
[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].sort_by{|m| -(m[1] + m[2] + m[3])]}
skandhas 10楼, 于23小时前回复 从楼主的例子直接翻译到Ruby
1 中国习惯上先按金牌数排名，金牌数一样的按银牌数再排，如果银牌数再一样就按铜牌数排：

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].sort_by{|x| [-x[1],-x[2],-x[3]]}
2 美国习惯上金牌银牌铜牌都是奖牌，所以按奖牌总数排序：

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].sort_by{|x| -(x[1]+x[2]+x[3])}
3 统计金牌数超过35的国家：

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].select{|x| x[1] &gt;35}
4 统计奖牌总数超过100的国家：

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].select{|x| x[1]+x[2]+x[3] &gt; 100}
这两个语言都挺类似，我觉得ruby的select更直观。

另 楼主这个帖子想表达什么？没看出什么来。如果说只通过sorted就说明python是为数据而生的话，那ruby不也是吗。哈哈

daqing 11楼, 于23小时前回复 我来写个Ruby版本的。

第一个，奖牌排序:

data = [[:china, 27, 26, 11], [:usa, 20, 22, 50], [:russia, 30, 33, 20]]

data.sort_by { |x| [-x[1], -x[2], -x[3]] } # 中国排序方法，按金/银/铜牌数
data.sort_by { |x| -(x[1] + x[2] + x[3]) } # 美国排序方法，按奖牌总数
第二个，奖牌统计:

data.select { |x| x[1] &gt; 35 } # 金牌数超过35的国家
data.select { |x| x[1] + x[2] + x[3] &gt; 100 } # 奖牌总数超过100的国家
哪个更简洁，一目了然了吧。

daqing 12楼, 于23小时前回复 原来大家都在回复。。等我写出来才发现。

daqing 13楼, 于23小时前回复 #10楼 @skandhas 看了你的方法，才想到，select是更直接的做法。collect方法会包含nil值。

reus 14楼, 于23小时前回复 Why I Hate Advocacy
<a href="http://www.perl.com/pub/2000/12/advocacy.html">http://www.perl.com/pub/2000/12/advocacy.html</a>

gaicitadie 15楼, 于23小时前回复 总统选举投票，初步唱票记录：

[&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
根据唱票记录统计每人的票数并按从多到少排序

&gt;&gt;&gt; l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
&gt;&gt;&gt; sorted(set([(i, l.count(i)) for i in l]), key=lambda x:-x[1])
[(&#8216;Jim&#8217;, 4), (&#8216;bush&#8217;, 2), (&#8216;obama&#8217;, 1)]
clearJiang 16楼, 于23小时前回复 #15楼 @gaicitadie 不如直接用collections.Counter

gaicitadie 17楼, 于23小时前回复 #16楼 @clearJiang 低版本没有collections

daqing 18楼, 于23小时前回复 总统选举投票

l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
l.uniq.collect { |x| [x, l.count(x)] }
=&gt; [[&#8220;Jim&#8221;, 4], [&#8220;bush&#8221;, 2], [&#8220;obama&#8221;, 1]]
skandhas 19楼, 于22小时前回复 #15楼 @gaicitadie
根据唱票记录统计每人的票数并按从多到少排序:

l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
l.group_by{|i| i}.map{|k,v| [k,v.length] }
quakewang 20楼, 于22小时前回复 python要和ruby比 文件、字符操作或者数组、Hash操作的便利性绝对完败，要砸场还不如在性能上一棍子打死ruby。

bony 21楼, 于22小时前回复 这样的帖子应该多一点。长知识。@skandhas cool.

quakewang 22楼, 于22小时前回复 #15楼 @gaicitadie

[&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;].inject(Hash.new(0)) {|h, e| h[e] += 1; h}.sort_by{|e| -e[1]}
daqing 23楼, 于22小时前回复 说实话，Python的lambda匿名函数，跟Ruby的Block相比，从书写上就败了。

gaicitadie 24楼, 于22小时前回复 随机设置验证码的4个字符(不包括图片处理部分)

&gt;&gt;&gt; import random
&gt;&gt;&gt; s = &#8216;ABCDEFGHIJKLMNPRSTUVWXYZ&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;EXSG&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;TGYN&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;MEYP&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;TGIF&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;JDWF&#8217;
quakewang 25楼, 于22小时前回复 #24楼 @gaicitadie

(&#8216;A&#8217;..&#8217;Z&#8217;).to_a.sample(4).join
reus 26楼, 于22小时前回复 #15楼 @gaicitadie 你这个算法是O(n ^ 2)的，应该用reduce

def stat(acc, x):
  acc.setdefault(x, 0)
  acc[x] += 1
  return acc
sorted(reduce(stat,
  [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;], {}).iteritems(),
    key = lambda x: -x[1])
huyong36 27楼, 于22小时前回复 @skandhas cool,加上个排序。

gaicitadie 28楼, 于22小时前回复 #26楼 @reus reduce不如列表解析快，虽然list.count会重复统计

skandhas 29楼, 于22小时前回复 #27楼 @huyong36
对，是忘了排序

l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
l.group_by{|i| i}.map{|k,v| [k,v.length] }.sort_by{|name,count| -count }
huacnlee 30楼, 于22小时前回复 风格不同而已，用起来都是一样方便。这个就是让我喜欢 Python 和 Ruby 的原因之一。

reus 31楼, 于22小时前回复 #28楼 @gaicitadie
就是慢在count调用上，for i in l遍历数组，且每个元素又再count遍历一次，O(n ^ 2)
reduce只需要遍历一次，O(n)
不信可以测试下

huyong36 32楼, 于22小时前回复 这帖应该是捧场帖,我喜欢这样的学习。

raecoo 33楼, 于22小时前回复 受用

hysios 34楼, 于21小时前回复 •字符串查找
# python
&gt;&gt;&gt; &#8216;11ab1111ab111ac11111&#8217;.count(&#8216;ab&#8217;)
2
# Ruby
ruby-1.9.2-p290 &gt;   &#8216;11ab111123ab111ac11111&#8217;.count &#8216;ab&#8217;, &#8216;b&#8217;
2
hysios 35楼, 于21小时前回复 •奖牌排序
# python
&gt;&gt;&gt; sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:(-x[1],-x[2],-x[3]))
[(&#8216;china&#8217;, 37, 26, 11), (&#8216;russia&#8217;, 30, 33, 20), (&#8216;usa&#8217;, 30, 22, 50)]
# ruby
ruby-1.9.2-p290 &gt; [[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50],[&#8216;russia&#8217;,30,33,20]].sort_by {|name,j,y,t| [-j,-y,-t] }
 =&gt; [[&#8220;china&#8221;, 37, 26, 11], [&#8220;russia&#8221;, 30, 33, 20], [&#8220;usa&#8221;, 30, 22, 50]]
hysios 36楼, 于21小时前回复 •奖牌统计
# python
&gt;&gt;&gt; sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:-(x[1]+x[2]+x[3]))
[(&#8216;usa&#8217;, 30, 22, 50), (&#8216;russia&#8217;, 30, 33, 20), (&#8216;china&#8217;, 37, 26, 11)]
# ruby
ruby-1.9.2-p290 &gt; [[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50],[&#8216;russia&#8217;,30,33,20]].sort_by {|name,j,y,t| [-j + -y + -t] }
 =&gt; [[&#8220;usa&#8221;, 30, 22, 50], [&#8220;russia&#8221;, 30, 33, 20], [&#8220;china&#8221;, 37, 26, 11]]
kfll 37楼, 于21小时前回复 捧场..
js:

&#8216;11ab1111ab111ac11111&#8217;.match(/ab/g).length;
&#8216;11ab1111ab111ac11111&#8217;.split(&#8216;ab&#8217;).length - 1;
中式排名：

[[37, 26, 11], [30, 22, 50], [30, 33, 20]].sort().reverse();
hysios 38楼, 于21小时前回复 总统选举投票，初步唱票记录：

# ruby
&gt;&gt;&gt; l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
&gt;&gt;&gt; sorted(set([(i, l.count(i)) for i in l]), key=lambda x:-x[1])
[(&#8216;Jim&#8217;, 4), (&#8216;bush&#8217;, 2), (&#8216;obama&#8217;, 1)]
# ruby
ruby-1.9.2-p290 &gt;  [&#8216;bush&#8217;,&#8217;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;].each_with_object({}) {|name,s| s[name] = s.fetch(name,0) + 1 }.sort
 =&gt; [[&#8220;Jim&#8221;, 4], [&#8220;bush&#8221;, 3], [&#8220;obama&#8221;, 1]]
huyong36 39楼, 于21小时前回复 #34楼 @hysios

&#8216;11ab111123ab111ac11111&#8217;.count &#8216;ab&#8217;, &#8216;b&#8217;
这样不对吧&#8230;这样只是找出来字符串里出现b的次数。

irb(main):106:0&gt; &#8216;11ab111123ab111ac11111b&#8217;.count &#8216;ab&#8217;, &#8216;b&#8217;
=&gt; 3
hysios 40楼, 于21小时前回复 @huyong36 thx count是没办法实现的, 别的方法也不错

huyong36 41楼, 于20小时前回复 #40楼 @hysios 恩,请教

irb(main):115:0&gt; &#8216;11ab111123ab111c11111&#8217;.count  &#8216;a&#8217;
=&gt; 2
irb(main):114:0&gt; &#8216;11ab111123ab111c11111&#8217;.count  &#8216;ab&#8217;
=&gt; 4
字符可以统计,为什么字符串不能。。

jhjguxin 42楼, 于20小时前回复 @huyong36
count([other_str]+) → fixnum click to toggle source
Each other_str parameter defines a set of characters to count. The intersection of these sets defines the characters to count in str. Any other_str that starts with a caret (^) is negated. The sequence c1–c2 means all characters between c1 and c2.

Guest 43楼, 于20小时前回复 gaicitadie = [[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].tap do |man|
  def man.make_self(&amp;process); process.call self; end
  def man.become_egghead
    `python -c &#8220;print( sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:(-x[1],-x[2],-x[3])) )&#8221;`
  end
  def man.glow_up
    dont_be_shy = true
    unless self.respond_to? :more_elegant, dont_be_shy
      def self.more_elegant
        self.sort_by { |country, glods, silvers, bronzes| [-glods,-silvers,-bronzes] }
      end
    end
    if self.respond_to? :become_egghead
      class &lt;&lt; self; remove_method :become_egghead; end
    end
    self
  end
end
gaicitadie.make_self &amp;:become_egghead
gaicitadie.glow_up.make_self &amp;:more_elegant
geekontheway 44楼, 于20小时前回复 #41楼 @huyong36 ruby的count 统计的是字符的数量 所以&#8217;11ab111123ab111c11111&#8217;.count &#8216;ab&#8217;等同于&#8217;11ab111123ab111c11111&#8217;.count &#8216;a&#8217; + &#8216;11ab111123ab111c11111&#8217;.count &#8216;b&#8217;

jhjguxin 45楼, 于20小时前回复 简而言之就是 取每一个字符的count的交集

huyong36 46楼, 于20小时前回复 @geekontheway @jhjguxin 3Q&#8230;

hysios 47楼, 于20小时前回复 #41楼 @huyong36 count 是统计所有的字符,并不会把参数当成字符串处理

FenRagwort 48楼, 于17小时前回复 合并两个字典/哈希，重复的项目，两个值相加

hash1.merge(hash2) {|dupkey,val1,val2| val1 + val2 }
楼主来个Python的写法？

hhuai 49楼, 于16小时前回复 method_missing, 楼主来个？？

gaicitadie 50楼, 于14小时前回复 #48楼 @FenRagwort ，这个暂时只想到了普通方法

for k,v in hash2.items():
    if k in hash1:
        hash1[k] += v
    else:
        hash1.setdefault(k,v)
zw963 51楼, 于12小时前回复 #19楼 @skandhas

的确酷, 不说说实在的. group_by用来做这个, 真是有点大才小用了.

reus 52楼, 于12小时前回复 #49楼 @hhuai

class Foo:
  def __getattr__(self, name):
    def _foo(*arg, **kwargs):
      return self.method_missing(name, *arg, **kwargs)
    return _foo

  def method_missing(self, name, *args, **kwargs):
    print name, args, kwargs

a = Foo()
a.foo(&#8216;bar&#8217;, baz = &#8216;baz&#8217;)

&nbsp;

huacnlee 1楼, 于24小时前回复 irb&gt; &#8216;11ab1111ab111ac11111&#8217;.scan(&#8220;ab&#8221;).count
2
ywencn 2楼, 于24小时前回复 1.9.2p290 :001 &gt;  &#8216;11ab1111ab111ac11111&#8217;.count(&#8216;ab&#8217;)
 =&gt; 5
楼主想表达什么？

ywencn 3楼, 于24小时前回复 哎呀。。。怎么python和ruby的count还不一样，哈哈

huacnlee 4楼, 于24小时前回复 Ruby 的 &#8220;&#8221;.count 统计的是后面所有的字符

dreamrise 5楼, 于24小时前回复 貌似_who还写过一个python与ruby转换的程序？

gaicitadie 6楼, 于23小时前回复 奥运奖牌榜：
国家 金牌数 银牌数 铜牌数
china 37 26 11
usa 30 22 50
russia 30 33 20

中国习惯上先按金牌数排名，金牌数一样的按银牌数再排，如果银牌数再一样就按铜牌数排：

&gt;&gt;&gt; sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:(-x[1],-x[2],-x[3]))
[(&#8216;china&#8217;, 37, 26, 11), (&#8216;russia&#8217;, 30, 33, 20), (&#8216;usa&#8217;, 30, 22, 50)]
美国习惯上金牌银牌铜牌都是奖牌，所以按奖牌总数排序：

&gt;&gt;&gt; sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:-(x[1]+x[2]+x[3]))
[(&#8216;usa&#8217;, 30, 22, 50), (&#8216;russia&#8217;, 30, 33, 20), (&#8216;china&#8217;, 37, 26, 11)]
python的排序达到了类似SQL查询的能力，只需要告诉它排序的条件就可以了，python为数据而生

gaicitadie 7楼, 于23小时前回复 上面的例子是python模拟SQL的order by功能，下面的例子用python模拟SQL的where条件查询

统计金牌数超过35的国家：

&gt;&gt;&gt; [x for x in [(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)] if x[1]&gt;35]
[(&#8216;china&#8217;, 37, 26, 11)]
统计奖牌总数超过100的国家：

&gt;&gt;&gt; [x for x in [(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)] if x[1]+x[2]+x[3]&gt;100]
[(&#8216;usa&#8217;, 30, 22, 50)]
huyong36 8楼, 于23小时前回复 @gaicitadie ruby是

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].select{|x| x[1] &gt; 35}
[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].select{|x| x[1] + x[2] + x[3] &gt; 100}
quakewang 9楼, 于23小时前回复 #6楼 @gaicitadie
order by 的ruby代码

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].sort_by{|m| [-m[1], -m[2], -m[3]]}
[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].sort_by{|m| -(m[1] + m[2] + m[3])]}
skandhas 10楼, 于23小时前回复 从楼主的例子直接翻译到Ruby
1 中国习惯上先按金牌数排名，金牌数一样的按银牌数再排，如果银牌数再一样就按铜牌数排：

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].sort_by{|x| [-x[1],-x[2],-x[3]]}
2 美国习惯上金牌银牌铜牌都是奖牌，所以按奖牌总数排序：

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].sort_by{|x| -(x[1]+x[2]+x[3])}
3 统计金牌数超过35的国家：

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].select{|x| x[1] &gt;35}
4 统计奖牌总数超过100的国家：

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].select{|x| x[1]+x[2]+x[3] &gt; 100}
这两个语言都挺类似，我觉得ruby的select更直观。

另 楼主这个帖子想表达什么？没看出什么来。如果说只通过sorted就说明python是为数据而生的话，那ruby不也是吗。哈哈

daqing 11楼, 于23小时前回复 我来写个Ruby版本的。

第一个，奖牌排序:

data = [[:china, 27, 26, 11], [:usa, 20, 22, 50], [:russia, 30, 33, 20]]

data.sort_by { |x| [-x[1], -x[2], -x[3]] } # 中国排序方法，按金/银/铜牌数
data.sort_by { |x| -(x[1] + x[2] + x[3]) } # 美国排序方法，按奖牌总数
第二个，奖牌统计:

data.select { |x| x[1] &gt; 35 } # 金牌数超过35的国家
data.select { |x| x[1] + x[2] + x[3] &gt; 100 } # 奖牌总数超过100的国家
哪个更简洁，一目了然了吧。

daqing 12楼, 于23小时前回复 原来大家都在回复。。等我写出来才发现。

daqing 13楼, 于23小时前回复 #10楼 @skandhas 看了你的方法，才想到，select是更直接的做法。collect方法会包含nil值。

reus 14楼, 于23小时前回复 Why I Hate Advocacy
<a href="http://www.perl.com/pub/2000/12/advocacy.html">http://www.perl.com/pub/2000/12/advocacy.html</a>

gaicitadie 15楼, 于23小时前回复 总统选举投票，初步唱票记录：

[&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
根据唱票记录统计每人的票数并按从多到少排序

&gt;&gt;&gt; l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
&gt;&gt;&gt; sorted(set([(i, l.count(i)) for i in l]), key=lambda x:-x[1])
[(&#8216;Jim&#8217;, 4), (&#8216;bush&#8217;, 2), (&#8216;obama&#8217;, 1)]
clearJiang 16楼, 于23小时前回复 #15楼 @gaicitadie 不如直接用collections.Counter

gaicitadie 17楼, 于23小时前回复 #16楼 @clearJiang 低版本没有collections

daqing 18楼, 于23小时前回复 总统选举投票

l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
l.uniq.collect { |x| [x, l.count(x)] }
=&gt; [[&#8220;Jim&#8221;, 4], [&#8220;bush&#8221;, 2], [&#8220;obama&#8221;, 1]]
skandhas 19楼, 于22小时前回复 #15楼 @gaicitadie
根据唱票记录统计每人的票数并按从多到少排序:

l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
l.group_by{|i| i}.map{|k,v| [k,v.length] }
quakewang 20楼, 于22小时前回复 python要和ruby比 文件、字符操作或者数组、Hash操作的便利性绝对完败，要砸场还不如在性能上一棍子打死ruby。

bony 21楼, 于22小时前回复 这样的帖子应该多一点。长知识。@skandhas cool.

quakewang 22楼, 于22小时前回复 #15楼 @gaicitadie

[&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;].inject(Hash.new(0)) {|h, e| h[e] += 1; h}.sort_by{|e| -e[1]}
daqing 23楼, 于22小时前回复 说实话，Python的lambda匿名函数，跟Ruby的Block相比，从书写上就败了。

gaicitadie 24楼, 于22小时前回复 随机设置验证码的4个字符(不包括图片处理部分)

&gt;&gt;&gt; import random
&gt;&gt;&gt; s = &#8216;ABCDEFGHIJKLMNPRSTUVWXYZ&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;EXSG&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;TGYN&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;MEYP&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;TGIF&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;JDWF&#8217;
quakewang 25楼, 于22小时前回复 #24楼 @gaicitadie

(&#8216;A&#8217;..&#8217;Z&#8217;).to_a.sample(4).join
reus 26楼, 于22小时前回复 #15楼 @gaicitadie 你这个算法是O(n ^ 2)的，应该用reduce

def stat(acc, x):
  acc.setdefault(x, 0)
  acc[x] += 1
  return acc
sorted(reduce(stat,
  [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;], {}).iteritems(),
    key = lambda x: -x[1])
huyong36 27楼, 于22小时前回复 @skandhas cool,加上个排序。

gaicitadie 28楼, 于22小时前回复 #26楼 @reus reduce不如列表解析快，虽然list.count会重复统计

skandhas 29楼, 于22小时前回复 #27楼 @huyong36
对，是忘了排序

l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
l.group_by{|i| i}.map{|k,v| [k,v.length] }.sort_by{|name,count| -count }
huacnlee 30楼, 于22小时前回复 风格不同而已，用起来都是一样方便。这个就是让我喜欢 Python 和 Ruby 的原因之一。

reus 31楼, 于22小时前回复 #28楼 @gaicitadie
就是慢在count调用上，for i in l遍历数组，且每个元素又再count遍历一次，O(n ^ 2)
reduce只需要遍历一次，O(n)
不信可以测试下

huyong36 32楼, 于22小时前回复 这帖应该是捧场帖,我喜欢这样的学习。

raecoo 33楼, 于22小时前回复 受用

hysios 34楼, 于21小时前回复 •字符串查找
# python
&gt;&gt;&gt; &#8216;11ab1111ab111ac11111&#8217;.count(&#8216;ab&#8217;)
2
# Ruby
ruby-1.9.2-p290 &gt;   &#8216;11ab111123ab111ac11111&#8217;.count &#8216;ab&#8217;, &#8216;b&#8217;
2
hysios 35楼, 于21小时前回复 •奖牌排序
# python
&gt;&gt;&gt; sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:(-x[1],-x[2],-x[3]))
[(&#8216;china&#8217;, 37, 26, 11), (&#8216;russia&#8217;, 30, 33, 20), (&#8216;usa&#8217;, 30, 22, 50)]
# ruby
ruby-1.9.2-p290 &gt; [[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50],[&#8216;russia&#8217;,30,33,20]].sort_by {|name,j,y,t| [-j,-y,-t] }
 =&gt; [[&#8220;china&#8221;, 37, 26, 11], [&#8220;russia&#8221;, 30, 33, 20], [&#8220;usa&#8221;, 30, 22, 50]]
hysios 36楼, 于21小时前回复 •奖牌统计
# python
&gt;&gt;&gt; sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:-(x[1]+x[2]+x[3]))
[(&#8216;usa&#8217;, 30, 22, 50), (&#8216;russia&#8217;, 30, 33, 20), (&#8216;china&#8217;, 37, 26, 11)]
# ruby
ruby-1.9.2-p290 &gt; [[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50],[&#8216;russia&#8217;,30,33,20]].sort_by {|name,j,y,t| [-j + -y + -t] }
 =&gt; [[&#8220;usa&#8221;, 30, 22, 50], [&#8220;russia&#8221;, 30, 33, 20], [&#8220;china&#8221;, 37, 26, 11]]
kfll 37楼, 于21小时前回复 捧场..
js:

&#8216;11ab1111ab111ac11111&#8217;.match(/ab/g).length;
&#8216;11ab1111ab111ac11111&#8217;.split(&#8216;ab&#8217;).length - 1;
中式排名：

[[37, 26, 11], [30, 22, 50], [30, 33, 20]].sort().reverse();
hysios 38楼, 于21小时前回复 总统选举投票，初步唱票记录：

# ruby
&gt;&gt;&gt; l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
&gt;&gt;&gt; sorted(set([(i, l.count(i)) for i in l]), key=lambda x:-x[1])
[(&#8216;Jim&#8217;, 4), (&#8216;bush&#8217;, 2), (&#8216;obama&#8217;, 1)]
# ruby
ruby-1.9.2-p290 &gt;  [&#8216;bush&#8217;,&#8217;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;].each_with_object({}) {|name,s| s[name] = s.fetch(name,0) + 1 }.sort
 =&gt; [[&#8220;Jim&#8221;, 4], [&#8220;bush&#8221;, 3], [&#8220;obama&#8221;, 1]]
huyong36 39楼, 于21小时前回复 #34楼 @hysios

&#8216;11ab111123ab111ac11111&#8217;.count &#8216;ab&#8217;, &#8216;b&#8217;
这样不对吧&#8230;这样只是找出来字符串里出现b的次数。

irb(main):106:0&gt; &#8216;11ab111123ab111ac11111b&#8217;.count &#8216;ab&#8217;, &#8216;b&#8217;
=&gt; 3
hysios 40楼, 于21小时前回复 @huyong36 thx count是没办法实现的, 别的方法也不错

huyong36 41楼, 于20小时前回复 #40楼 @hysios 恩,请教

irb(main):115:0&gt; &#8216;11ab111123ab111c11111&#8217;.count  &#8216;a&#8217;
=&gt; 2
irb(main):114:0&gt; &#8216;11ab111123ab111c11111&#8217;.count  &#8216;ab&#8217;
=&gt; 4
字符可以统计,为什么字符串不能。。

jhjguxin 42楼, 于20小时前回复 @huyong36
count([other_str]+) → fixnum click to toggle source
Each other_str parameter defines a set of characters to count. The intersection of these sets defines the characters to count in str. Any other_str that starts with a caret (^) is negated. The sequence c1–c2 means all characters between c1 and c2.

Guest 43楼, 于20小时前回复 gaicitadie = [[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].tap do |man|
  def man.make_self(&amp;process); process.call self; end
  def man.become_egghead
    `python -c &#8220;print( sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:(-x[1],-x[2],-x[3])) )&#8221;`
  end
  def man.glow_up
    dont_be_shy = true
    unless self.respond_to? :more_elegant, dont_be_shy
      def self.more_elegant
        self.sort_by { |country, glods, silvers, bronzes| [-glods,-silvers,-bronzes] }
      end
    end
    if self.respond_to? :become_egghead
      class &lt;&lt; self; remove_method :become_egghead; end
    end
    self
  end
end
gaicitadie.make_self &amp;:become_egghead
gaicitadie.glow_up.make_self &amp;:more_elegant
geekontheway 44楼, 于20小时前回复 #41楼 @huyong36 ruby的count 统计的是字符的数量 所以&#8217;11ab111123ab111c11111&#8217;.count &#8216;ab&#8217;等同于&#8217;11ab111123ab111c11111&#8217;.count &#8216;a&#8217; + &#8216;11ab111123ab111c11111&#8217;.count &#8216;b&#8217;

jhjguxin 45楼, 于20小时前回复 简而言之就是 取每一个字符的count的交集

huyong36 46楼, 于20小时前回复 @geekontheway @jhjguxin 3Q&#8230;

hysios 47楼, 于20小时前回复 #41楼 @huyong36 count 是统计所有的字符,并不会把参数当成字符串处理

FenRagwort 48楼, 于17小时前回复 合并两个字典/哈希，重复的项目，两个值相加

hash1.merge(hash2) {|dupkey,val1,val2| val1 + val2 }
楼主来个Python的写法？

hhuai 49楼, 于16小时前回复 method_missing, 楼主来个？？

gaicitadie 50楼, 于14小时前回复 #48楼 @FenRagwort ，这个暂时只想到了普通方法

for k,v in hash2.items():
    if k in hash1:
        hash1[k] += v
    else:
        hash1.setdefault(k,v)
zw963 51楼, 于12小时前回复 #19楼 @skandhas

的确酷, 不说说实在的. group_by用来做这个, 真是有点大才小用了.

reus 52楼, 于12小时前回复 #49楼 @hhuai

class Foo:
  def __getattr__(self, name):
    def _foo(*arg, **kwargs):
      return self.method_missing(name, *arg, **kwargs)
    return _foo

  def method_missing(self, name, *args, **kwargs):
    print name, args, kwargs

a = Foo()
a.foo(&#8216;bar&#8217;, baz = &#8216;baz&#8217;)

&nbsp;

huacnlee 1楼, 于24小时前回复 irb&gt; &#8216;11ab1111ab111ac11111&#8217;.scan(&#8220;ab&#8221;).count
2
ywencn 2楼, 于24小时前回复 1.9.2p290 :001 &gt;  &#8216;11ab1111ab111ac11111&#8217;.count(&#8216;ab&#8217;)
 =&gt; 5
楼主想表达什么？

ywencn 3楼, 于24小时前回复 哎呀。。。怎么python和ruby的count还不一样，哈哈

huacnlee 4楼, 于24小时前回复 Ruby 的 &#8220;&#8221;.count 统计的是后面所有的字符

dreamrise 5楼, 于24小时前回复 貌似_who还写过一个python与ruby转换的程序？

gaicitadie 6楼, 于23小时前回复 奥运奖牌榜：
国家 金牌数 银牌数 铜牌数
china 37 26 11
usa 30 22 50
russia 30 33 20

中国习惯上先按金牌数排名，金牌数一样的按银牌数再排，如果银牌数再一样就按铜牌数排：

&gt;&gt;&gt; sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:(-x[1],-x[2],-x[3]))
[(&#8216;china&#8217;, 37, 26, 11), (&#8216;russia&#8217;, 30, 33, 20), (&#8216;usa&#8217;, 30, 22, 50)]
美国习惯上金牌银牌铜牌都是奖牌，所以按奖牌总数排序：

&gt;&gt;&gt; sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:-(x[1]+x[2]+x[3]))
[(&#8216;usa&#8217;, 30, 22, 50), (&#8216;russia&#8217;, 30, 33, 20), (&#8216;china&#8217;, 37, 26, 11)]
python的排序达到了类似SQL查询的能力，只需要告诉它排序的条件就可以了，python为数据而生

gaicitadie 7楼, 于23小时前回复 上面的例子是python模拟SQL的order by功能，下面的例子用python模拟SQL的where条件查询

统计金牌数超过35的国家：

&gt;&gt;&gt; [x for x in [(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)] if x[1]&gt;35]
[(&#8216;china&#8217;, 37, 26, 11)]
统计奖牌总数超过100的国家：

&gt;&gt;&gt; [x for x in [(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)] if x[1]+x[2]+x[3]&gt;100]
[(&#8216;usa&#8217;, 30, 22, 50)]
huyong36 8楼, 于23小时前回复 @gaicitadie ruby是

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].select{|x| x[1] &gt; 35}
[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].select{|x| x[1] + x[2] + x[3] &gt; 100}
quakewang 9楼, 于23小时前回复 #6楼 @gaicitadie
order by 的ruby代码

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].sort_by{|m| [-m[1], -m[2], -m[3]]}
[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].sort_by{|m| -(m[1] + m[2] + m[3])]}
skandhas 10楼, 于23小时前回复 从楼主的例子直接翻译到Ruby
1 中国习惯上先按金牌数排名，金牌数一样的按银牌数再排，如果银牌数再一样就按铜牌数排：

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].sort_by{|x| [-x[1],-x[2],-x[3]]}
2 美国习惯上金牌银牌铜牌都是奖牌，所以按奖牌总数排序：

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].sort_by{|x| -(x[1]+x[2]+x[3])}
3 统计金牌数超过35的国家：

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].select{|x| x[1] &gt;35}
4 统计奖牌总数超过100的国家：

[[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].select{|x| x[1]+x[2]+x[3] &gt; 100}
这两个语言都挺类似，我觉得ruby的select更直观。

另 楼主这个帖子想表达什么？没看出什么来。如果说只通过sorted就说明python是为数据而生的话，那ruby不也是吗。哈哈

daqing 11楼, 于23小时前回复 我来写个Ruby版本的。

第一个，奖牌排序:

data = [[:china, 27, 26, 11], [:usa, 20, 22, 50], [:russia, 30, 33, 20]]

data.sort_by { |x| [-x[1], -x[2], -x[3]] } # 中国排序方法，按金/银/铜牌数
data.sort_by { |x| -(x[1] + x[2] + x[3]) } # 美国排序方法，按奖牌总数
第二个，奖牌统计:

data.select { |x| x[1] &gt; 35 } # 金牌数超过35的国家
data.select { |x| x[1] + x[2] + x[3] &gt; 100 } # 奖牌总数超过100的国家
哪个更简洁，一目了然了吧。

daqing 12楼, 于23小时前回复 原来大家都在回复。。等我写出来才发现。

daqing 13楼, 于23小时前回复 #10楼 @skandhas 看了你的方法，才想到，select是更直接的做法。collect方法会包含nil值。

reus 14楼, 于23小时前回复 Why I Hate Advocacy
<a href="http://www.perl.com/pub/2000/12/advocacy.html">http://www.perl.com/pub/2000/12/advocacy.html</a>

gaicitadie 15楼, 于23小时前回复 总统选举投票，初步唱票记录：

[&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
根据唱票记录统计每人的票数并按从多到少排序

&gt;&gt;&gt; l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
&gt;&gt;&gt; sorted(set([(i, l.count(i)) for i in l]), key=lambda x:-x[1])
[(&#8216;Jim&#8217;, 4), (&#8216;bush&#8217;, 2), (&#8216;obama&#8217;, 1)]
clearJiang 16楼, 于23小时前回复 #15楼 @gaicitadie 不如直接用collections.Counter

gaicitadie 17楼, 于23小时前回复 #16楼 @clearJiang 低版本没有collections

daqing 18楼, 于23小时前回复 总统选举投票

l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
l.uniq.collect { |x| [x, l.count(x)] }
=&gt; [[&#8220;Jim&#8221;, 4], [&#8220;bush&#8221;, 2], [&#8220;obama&#8221;, 1]]
skandhas 19楼, 于22小时前回复 #15楼 @gaicitadie
根据唱票记录统计每人的票数并按从多到少排序:

l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
l.group_by{|i| i}.map{|k,v| [k,v.length] }
quakewang 20楼, 于22小时前回复 python要和ruby比 文件、字符操作或者数组、Hash操作的便利性绝对完败，要砸场还不如在性能上一棍子打死ruby。

bony 21楼, 于22小时前回复 这样的帖子应该多一点。长知识。@skandhas cool.

quakewang 22楼, 于22小时前回复 #15楼 @gaicitadie

[&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;].inject(Hash.new(0)) {|h, e| h[e] += 1; h}.sort_by{|e| -e[1]}
daqing 23楼, 于22小时前回复 说实话，Python的lambda匿名函数，跟Ruby的Block相比，从书写上就败了。

gaicitadie 24楼, 于22小时前回复 随机设置验证码的4个字符(不包括图片处理部分)

&gt;&gt;&gt; import random
&gt;&gt;&gt; s = &#8216;ABCDEFGHIJKLMNPRSTUVWXYZ&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;EXSG&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;TGYN&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;MEYP&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;TGIF&#8217;
&gt;&gt;&gt; &#8221;.join(random.sample((s),4))
&#8216;JDWF&#8217;
quakewang 25楼, 于22小时前回复 #24楼 @gaicitadie

(&#8216;A&#8217;..&#8217;Z&#8217;).to_a.sample(4).join
reus 26楼, 于22小时前回复 #15楼 @gaicitadie 你这个算法是O(n ^ 2)的，应该用reduce

def stat(acc, x):
  acc.setdefault(x, 0)
  acc[x] += 1
  return acc
sorted(reduce(stat,
  [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;], {}).iteritems(),
    key = lambda x: -x[1])
huyong36 27楼, 于22小时前回复 @skandhas cool,加上个排序。

gaicitadie 28楼, 于22小时前回复 #26楼 @reus reduce不如列表解析快，虽然list.count会重复统计

skandhas 29楼, 于22小时前回复 #27楼 @huyong36
对，是忘了排序

l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
l.group_by{|i| i}.map{|k,v| [k,v.length] }.sort_by{|name,count| -count }
huacnlee 30楼, 于22小时前回复 风格不同而已，用起来都是一样方便。这个就是让我喜欢 Python 和 Ruby 的原因之一。

reus 31楼, 于22小时前回复 #28楼 @gaicitadie
就是慢在count调用上，for i in l遍历数组，且每个元素又再count遍历一次，O(n ^ 2)
reduce只需要遍历一次，O(n)
不信可以测试下

huyong36 32楼, 于22小时前回复 这帖应该是捧场帖,我喜欢这样的学习。

raecoo 33楼, 于22小时前回复 受用

hysios 34楼, 于21小时前回复 •字符串查找
# python
&gt;&gt;&gt; &#8216;11ab1111ab111ac11111&#8217;.count(&#8216;ab&#8217;)
2
# Ruby
ruby-1.9.2-p290 &gt;   &#8216;11ab111123ab111ac11111&#8217;.count &#8216;ab&#8217;, &#8216;b&#8217;
2
hysios 35楼, 于21小时前回复 •奖牌排序
# python
&gt;&gt;&gt; sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:(-x[1],-x[2],-x[3]))
[(&#8216;china&#8217;, 37, 26, 11), (&#8216;russia&#8217;, 30, 33, 20), (&#8216;usa&#8217;, 30, 22, 50)]
# ruby
ruby-1.9.2-p290 &gt; [[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50],[&#8216;russia&#8217;,30,33,20]].sort_by {|name,j,y,t| [-j,-y,-t] }
 =&gt; [[&#8220;china&#8221;, 37, 26, 11], [&#8220;russia&#8221;, 30, 33, 20], [&#8220;usa&#8221;, 30, 22, 50]]
hysios 36楼, 于21小时前回复 •奖牌统计
# python
&gt;&gt;&gt; sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:-(x[1]+x[2]+x[3]))
[(&#8216;usa&#8217;, 30, 22, 50), (&#8216;russia&#8217;, 30, 33, 20), (&#8216;china&#8217;, 37, 26, 11)]
# ruby
ruby-1.9.2-p290 &gt; [[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50],[&#8216;russia&#8217;,30,33,20]].sort_by {|name,j,y,t| [-j + -y + -t] }
 =&gt; [[&#8220;usa&#8221;, 30, 22, 50], [&#8220;russia&#8221;, 30, 33, 20], [&#8220;china&#8221;, 37, 26, 11]]
kfll 37楼, 于21小时前回复 捧场..
js:

&#8216;11ab1111ab111ac11111&#8217;.match(/ab/g).length;
&#8216;11ab1111ab111ac11111&#8217;.split(&#8216;ab&#8217;).length - 1;
中式排名：

[[37, 26, 11], [30, 22, 50], [30, 33, 20]].sort().reverse();
hysios 38楼, 于21小时前回复 总统选举投票，初步唱票记录：

# ruby
&gt;&gt;&gt; l = [&#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;]
&gt;&gt;&gt; sorted(set([(i, l.count(i)) for i in l]), key=lambda x:-x[1])
[(&#8216;Jim&#8217;, 4), (&#8216;bush&#8217;, 2), (&#8216;obama&#8217;, 1)]
# ruby
ruby-1.9.2-p290 &gt;  [&#8216;bush&#8217;,&#8217;Jim&#8217;, &#8216;bush&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;Jim&#8217;, &#8216;bush&#8217;, &#8216;obama&#8217;].each_with_object({}) {|name,s| s[name] = s.fetch(name,0) + 1 }.sort
 =&gt; [[&#8220;Jim&#8221;, 4], [&#8220;bush&#8221;, 3], [&#8220;obama&#8221;, 1]]
huyong36 39楼, 于21小时前回复 #34楼 @hysios

&#8216;11ab111123ab111ac11111&#8217;.count &#8216;ab&#8217;, &#8216;b&#8217;
这样不对吧&#8230;这样只是找出来字符串里出现b的次数。

irb(main):106:0&gt; &#8216;11ab111123ab111ac11111b&#8217;.count &#8216;ab&#8217;, &#8216;b&#8217;
=&gt; 3
hysios 40楼, 于21小时前回复 @huyong36 thx count是没办法实现的, 别的方法也不错

huyong36 41楼, 于20小时前回复 #40楼 @hysios 恩,请教

irb(main):115:0&gt; &#8216;11ab111123ab111c11111&#8217;.count  &#8216;a&#8217;
=&gt; 2
irb(main):114:0&gt; &#8216;11ab111123ab111c11111&#8217;.count  &#8216;ab&#8217;
=&gt; 4
字符可以统计,为什么字符串不能。。

jhjguxin 42楼, 于20小时前回复 @huyong36
count([other_str]+) → fixnum click to toggle source
Each other_str parameter defines a set of characters to count. The intersection of these sets defines the characters to count in str. Any other_str that starts with a caret (^) is negated. The sequence c1–c2 means all characters between c1 and c2.

Guest 43楼, 于20小时前回复 gaicitadie = [[&#8216;china&#8217;,37,26,11], [&#8216;usa&#8217;,30,22,50], [&#8216;russia&#8217;,30,33,20]].tap do |man|
  def man.make_self(&amp;process); process.call self; end
  def man.become_egghead
    `python -c &#8220;print( sorted([(&#8216;china&#8217;,37,26,11), (&#8216;usa&#8217;,30,22,50), (&#8216;russia&#8217;,30,33,20)], key=lambda x:(-x[1],-x[2],-x[3])) )&#8221;`
  end
  def man.glow_up
    dont_be_shy = true
    unless self.respond_to? :more_elegant, dont_be_shy
      def self.more_elegant
        self.sort_by { |country, glods, silvers, bronzes| [-glods,-silvers,-bronzes] }
      end
    end
    if self.respond_to? :become_egghead
      class &lt;&lt; self; remove_method :become_egghead; end
    end
    self
  end
end
gaicitadie.make_self &amp;:become_egghead
gaicitadie.glow_up.make_self &amp;:more_elegant
geekontheway 44楼, 于20小时前回复 #41楼 @huyong36 ruby的count 统计的是字符的数量 所以&#8217;11ab111123ab111c11111&#8217;.count &#8216;ab&#8217;等同于&#8217;11ab111123ab111c11111&#8217;.count &#8216;a&#8217; + &#8216;11ab111123ab111c11111&#8217;.count &#8216;b&#8217;

jhjguxin 45楼, 于20小时前回复 简而言之就是 取每一个字符的count的交集

huyong36 46楼, 于20小时前回复 @geekontheway @jhjguxin 3Q&#8230;

hysios 47楼, 于20小时前回复 #41楼 @huyong36 count 是统计所有的字符,并不会把参数当成字符串处理

FenRagwort 48楼, 于17小时前回复 合并两个字典/哈希，重复的项目，两个值相加

hash1.merge(hash2) {|dupkey,val1,val2| val1 + val2 }
楼主来个Python的写法？

hhuai 49楼, 于16小时前回复 method_missing, 楼主来个？？

gaicitadie 50楼, 于14小时前回复 #48楼 @FenRagwort ，这个暂时只想到了普通方法

for k,v in hash2.items():
    if k in hash1:
        hash1[k] += v
    else:
        hash1.setdefault(k,v)
zw963 51楼, 于12小时前回复 #19楼 @skandhas

的确酷, 不说说实在的. group_by用来做这个, 真是有点大才小用了.

reus 52楼, 于12小时前回复 #49楼 @hhuai

class Foo:
  def __getattr__(self, name):
    def _foo(*arg, **kwargs):
      return self.method_missing(name, *arg, **kwargs)
    return _foo

  def method_missing(self, name, *args, **kwargs):
    print name, args, kwargs

a = Foo()
a.foo(&#8216;bar&#8217;, baz = &#8216;baz&#8217;)

&nbsp;

Francis.J(864248765)  13:19:50
&gt;&gt;&gt; l=[&#8216;a&#8217;,&#8217;a&#8217;,&#8217;b&#8217;,&#8217;b&#8217;,&#8217;b&#8217;,&#8217;c&#8217;,&#8217;c&#8217;]

&gt;&gt;&gt; sorted(set([i for i in l]))
[&#8216;a&#8217;, &#8216;b&#8217;, &#8216;c&#8217;]
Francis.J(864248765)  13:20:01
这样还行
Francis.J(864248765)  13:21:15
但是感觉 没有 pop 省资源
GG(75865965)  13:26:39
cat cat source.txt |uniq

</div>
</div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/19/helper-antipatterns/">Helper Antipatterns</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-19T10:44:00+08:00" pubdate data-updated="true">Mar 19<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Helper Antipatterns</h2>

<h2>Helper AntiPatterns</h2>


<p>Helper （輔助方法）的存在目的是用來輔助整理 View 中內嵌的複雜 Ruby 程式碼。設計得當的 Helper 可以加速專案的開發，以及增進程式的可讀性。然而，設計不好的 Helper 卻可能造成嚴重的反效果。</p>

<p>以下列舉常見的幾種糟糕的 Helper 設計模式：</p>

<h3>1. 矯往過正：用 Helper 作 partial 該做的事</h3>


<p>開發者以為 partial 效率是低下的，刻意不使用 partial，而改用 Helper 完成所有的動作：將需要重複使用的 HTML 通通寫成了 Ruby code，串接成 HTML：
def show_index_block(block_name, post, is_show_game)</p>

<p>block_title = content_tag(:h3, block_name)
section_header = content_tag(:div, block_title, :class =&gt; &ldquo;section-header&rdquo;)</p>

<p>game_name = is_show_game ? &ldquo;【 #{post.games.first.name} 】&rdquo; : &ldquo;&rdquo;
title = content_tag(:h4, link_to(&ldquo;#{game_name} #{post.title}&rdquo;, post_path(post)))
image = content_tag(:div, render_post_image(post), :class =&gt; &ldquo;thumbnail&rdquo;)
content = content_tag(:p, truncate( post.content, :length =&gt; 100))
section_content = content_tag(:div, &ldquo;#{title}#{image}#{content}&rdquo;, :class =&gt; &ldquo;section-content&rdquo;)</p>

<p>section_footer = content_tag(:div, link_to(&ldquo;閱讀全文&rdquo;, post_path(post)), :class =&gt; &ldquo;section-footer&rdquo;)</p>

<p>return content_tag(:div, &ldquo;#{section_header}#{section_content}#{section_footer}&rdquo; , :class =&gt; &ldquo;article-teaser&rdquo;)
end
 Helper 的作用只是協助整理 HTML 中的邏輯程式碼。若有大片 HTML 需要重複使用，應當需要利用 partial 機制進行 HTML 的重複利用。這樣的寫法，非但效率低下（可以用 HTML 產生，卻使用 Ruby 呼叫 Tag Helper，且製造大量 Ruby Object），且嚴重降低程式的可讀性，其他維護者將難以對這樣的 DOM 進行後續的維護翻修。</p>

<p>&nbsp;</p>

<p> 
2. 容易混淆：在 Helper 裡面穿插 HTML tag</p>

<p>這也是另外一個矯枉過正的例子，不過方向剛好相反：「因為覺得使用 Ruby code 產生 HTML tag 可能浪費效能，而直接插入 HTML 在 Helper 裡面與 Ruby Code 混雜。」也造成了專案維護上的困難：因為 Ruby 中的字串是使用雙引號&#8221;，而 HTML 也是使用雙引號&#8221;，，所以就必須特別加入 \&ldquo; 跳脫，否則就可能造成 syntax error。
錯誤
def post_tags_tag(post, opts = {})</p>

<h1>&hellip;.</h1>

<p><span style="background-color: #ff9632;">raw tags.collect</span> { |tag| &ldquo;#{tag}&rdquo; }.join(&ldquo;, &rdquo;)
end
大量的 &ldquo; 混雜在程式碼裡面，嚴重造成程式的可閱讀性，而且發生 syntax error 時難以 debug。
def post_tags_tag(post, opts = {})</p>

<h1>&hellip;.</h1>

<p><span>raw tags.collect</span> { |tag| &ldquo;#{tag}&rdquo; }.join(&ldquo;, &rdquo;)
end
即便換成 &lsquo; 單引號，狀況並沒有好上多少。
def post_tags_tag(post, opts = {})</p>

<h1>&hellip;</h1>

<p><span>raw tags.collect</span> { |tag| link_to(tag,posts_path(:tag =&gt; tag)) }.join(&ldquo;, &rdquo;)
end
正確的作法應該是妥善使用 Rails 內建的 Helper，使 Helper 裡面維持著都是 Ruby code 的狀態，並且具有高可讀性。</p>

<ol>
<li>強耦合：把 CSS 應該做的事綁在 Ruby Helper 上。</li>
</ol>


<p>錯誤
def red_alert(message)
return content_tag(:span,message, :style =&gt; &ldquo;font-color: red;&rdquo;)
end</p>

<p>def green_notice(message)
return content_tag(:span,message, :style =&gt; &ldquo;font-color: green;&rdquo;)
end
開發者不熟悉 unobtrusive 的設計手法，直接就把 design 就綁上了 Ruby Helper。將來設計上若需要變更時，難以修改或擴充。
正確
def stickies(message, message_type)
content_tag(:span,message, :class =&gt; message_type.to_sym)
end</p>

<p><span class="alert">Please Login!! </span>
樣式應該由 CSS 決定，使用 CSS class 控制，而非強行綁在 Helper 上。
4. 重複發明輪子</p>

<p>Rails 已內建許多實用 Helper，開發者卻以較糟的方式重造輪子。在此舉幾個比較經典的案例：</p>

<p>cycle
如何設計 table 的雙色列效果？</p>

<p>&lt;% count = 0 &gt; &lt;table&gt; &lt;% @items.each do |item| %&gt; &lt;% if count % 2 == 0 %&gt; &lt;% css_class = &ldquo;even &rdquo;%&gt; &lt;% else %&gt; &lt;% css_class = &ldquo;odd&rdquo; %&gt; &lt;% end %&gt; &lt;tr class=&ldquo;&lt;%= css_class %&gt;&rdquo;&gt; &lt;td&gt;item&lt;/td&gt; &lt;/tr&gt; &lt;% count += 1%&gt; &lt;% end %&gt; &lt;/table&gt;</p>

<p>一般的想法會是使用兩種不同 CSS class : even 與 odd，著上不同的顏色。</p>

<p>&lt;table&gt; &lt;% @items.each_with_index do |item, count| %&gt; &lt;% if count % 2 == 0 %&gt; &lt;% css_class = &ldquo;even &rdquo;%&gt; &lt;% else %&gt; &lt;% css_class = &ldquo;odd&rdquo; %&gt; &lt;% end %&gt; &lt;tr class=&ldquo;&lt;%= css_class %&gt;&rdquo;&gt; &lt;td&gt;item&lt;/td&gt; &lt;/tr&gt; &lt;% count += 1%&gt; &lt;% end %&gt; &lt;/table&gt;</p>

<p>這是一般粗心者會犯的錯誤。實際上 Ruby 的 Array 內建 each_with_index，不需另外宣告一個 count。
優</p>

<p>&lt;table&gt; &lt;% @items.each_with_index do |item, count| %&gt; &lt;% if count % 2 == 0 %&gt; &lt;% css_class = &ldquo;even &rdquo;%&gt; &lt;% else %&gt; &lt;% css_class = &ldquo;odd&rdquo; %&gt; &lt;% end %&gt; &lt;tr class=&ldquo;&lt;%= css_class %&gt;&rdquo;&gt; &lt;td&gt;item&lt;/td&gt; &lt;/tr&gt; &lt;% count += 1%&gt; &lt;% end %&gt; &lt;/table&gt;</p>

<p>但其實還有更簡便的方法：Rails 內建了 <code>cycle</code> 這個 Helper。所以只要這樣寫就好了…</p>

<p>&lt;table&gt; &lt;% @items.each do |item| %&gt; &lt;trodd&#8221;, &ldquo;even&rdquo;) %&gt;&ldquo;&gt; &lt;td&gt;item&lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/table&gt;</p>

<h4>常用你可能不知道的 Helper</h4>


<p>限於篇幅，直接介紹幾個因為使用機率高，所以很容易被重造輪子的 Helper。開發者會寫出的相關 AntiPattern 部分就跳過了。</p>

<ul>
    <li><a href="http://apidock.com/rails/ActionView/Helpers/TextHelper/truncate">truncate</a></li>
    <li><a href="http://apidock.com/rails/ActionView/Helpers/TextHelper/auto_link">auto_link</a></li>
    <li><a href="http://apidock.com/rails/ActionView/Helpers/RecordTagHelper/div_for">div_for</a> &amp; <a href="http://apidock.com/rails/ActionController/RecordIdentifier/dom_id">dom_id</a></li>
    <li><a href="http://apidock.com/rails/ActionView/Helpers/TextHelper/simple_format">simple_format</a></li>
</ul>


<p><code>#TODO: examples</code></p>

<h2>5. Tell, dont ask</h2>


<h2>這也是在 View 中會常出現的問題，直接違反了 Law of Demeter 原則，而造成了效能問題。十之八九某個 View 緩慢無比，最後抓出來背後幾乎都是這樣的原因。</h2>


<p>不少開發者會設計出這樣的 helper：</p>

<p> 
def post_tags_tag(post, opts = {})
tags = post.tags
tags.collect { |tag| link_to(tag,posts_path(:tag =&gt; tag)) }.join(&ldquo;, &rdquo;)
end</p>

<p>這種寫法會造成在 View 中，執行迴圈時，造成不必要的大量 query (n+1)，以及在 View 中製造不確定數量的大量物件。View 不僅效率低落也無法被 optimized。
def post_tags_tag(post, tags, opts = {})
tags.collect { |tag| link_to(tag,posts_path(:tag =&gt; tag)) }.join(&ldquo;, &rdquo;)
end</p>

<p>def index
@posts = Post.recent.includes(:tags)
end
正確的方法是使用 Tell, dont ask 原則，主動告知會使用的物件，而非讓 Helper 去猜。並配合 ActiveRecord 的 includes 減少不必要的 query（ includes 可以製造 join query ，一次把需要的 posts 和 tags 撈出來）。</p>

<p>且在 controller query 有 object cache 效果，在 view 中則無。</p>

<p>小結</p>

<p>Helper 是 Rails Developer 時常在接觸的工具。但可惜的是，多數開發者卻無法將此利器使得稱手，反而造成了更多問題。在我所曾經參與的幾十個 Rails 專案中，很多設計和效能問題幾乎都是因為寫的不好的 View / Helper 中的 slow query 或伴隨產生的大量 object 所造成的 memory bloat 導致的。但參與專案的開發者並沒有那麼多的經驗，能夠抓出確切的病因，卻都將矛頭直接是 Rails 的效能問題，或者是沒打上 Cache 的關係。這樣的說法只是把問題掩蓋起來治標，而非治本。</p>

<p>下次若有遇到 performance issue，請先往 View 中瞧看看是不是裡面出現了問題。也許你很快就可以找到解答。</p>

<p>Posted by xdite Jan 12th, 2012</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/16/factory-girl-validation-failed/">Factory_girl Validation Failed</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-16T16:22:00+08:00" pubdate data-updated="true">Mar 16<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>factory_girl Validation failed</h2>

<p>You need to use a sequence to prevent the creation of user objects with the same email, since you must have a validation for the uniqueness of emails in your User model.</p>

<pre><code>Factory.sequence :email do |n|
  “test#{n}@example.com”
end

Factory.define :user do |user|
  user.name "Testing User"
  user.email { Factory.next(:email) }
  user.password "foobar"
  user.password_confirmation "foobar"
end
</code></pre>


<p>You can read more in the <a href="https://github.com/thoughtbot/factory_girl/wiki/Usage" rel="nofollow">Factory Girl documentation</a>.</p>

<p>&nbsp;</p>

<p>Using factory_girl to create several instances of a class that belongs to another class causes a Validation failed error.</p>

<p>This happens because each instance tries to automatically create the object to which it belongs. However since the first instance creates it, the following instances crash because the object already exists.</p>

<p>I have been struggling to solve this problem and it seems finally I arrived to a satisfactory solution.</p>

<p>The problem arises when there is a one to many relationship between to classes and I try to create several instances of a class.</p>

<p>In my case I have a subdomain which has many users:</p>

<p>class Subdomain &lt; ActiveRecord::Base validates_uniqueness_of :name, :case_sensitive =&gt; false
has_many :users
end
class User &lt; ActiveRecord::Base belongs_to: subdomain endThe factories are as follows: FactoryGirl.define do factory :subdomain do name &lsquo;test-subdomain&rsquo; end factory :user do subdomain email &lsquo;<a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#116;&#x65;&#115;&#116;&#x2d;&#117;&#x73;&#101;&#x72;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;">&#x74;&#101;&#115;&#x74;&#x2d;&#x75;&#115;&#101;&#114;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#x2e;&#x63;&#x6f;&#109;</a>&rsquo; password &lsquo;123456¿ password_confirmation &#8216;123456&rsquo; end endWhen I try to create two users using the following code: FactoryGirl.create(:user, :email =&gt; &ldquo;<a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x66;&#x69;&#114;&#x73;&#116;&#x40;&#101;&#x78;&#97;&#109;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#x6d;">&#x66;&#105;&#x72;&#115;&#x74;&#64;&#x65;&#120;&#x61;&#109;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;</a>&rdquo;)
FactoryGirl.create(:user, :email =&gt; &ldquo;<a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x73;&#x65;&#99;&#x6f;&#x6e;&#100;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#x6d;">&#115;&#x65;&#99;&#111;&#110;&#100;&#x40;&#101;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#x6f;&#109;</a>&rdquo;)I get the following error:</p>

<p>Validation failed: Name has already been taken (ActiveRecord::RecordInvalid)This happens because when the first user is created, the default subdomain is created too and when the second user is created the subdomain already exists.</p>

<p>If we want to use the same subdomain for both users we can do the following:</p>

<p>s = FactoryGirl.create(:subdomain)
FactoryGirl.create(:user, :email =&gt; &ldquo;<a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x66;&#105;&#x72;&#x73;&#116;&#64;&#x65;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;">&#x66;&#x69;&#x72;&#115;&#x74;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#x2e;&#x63;&#x6f;&#109;</a>&rdquo;, :subdomain =&gt; s)
FactoryGirl.create(:user, :email =&gt; &ldquo;<a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#115;&#101;&#99;&#111;&#110;&#100;&#x40;&#x65;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#109;">&#x73;&#101;&#x63;&#x6f;&#110;&#x64;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#46;&#99;&#111;&#109;</a>&rdquo;, :subdomain =&gt; s)However as our has_many relations become deeper, test data creation becomes more complex.</p>

<p>My solution to this problem is as to change the factory for user:</p>

<p>factory :user do
subdomain { Subdomain.find_by_name(&lsquo;test-subdomain&rsquo;) || FactoryGirl.create(:subdomain) }
email &lsquo;<a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#x74;&#x65;&#x73;&#x74;&#45;&#x75;&#115;&#x65;&#x72;&#x40;&#x65;&#120;&#x61;&#x6d;&#112;&#108;&#x65;&#46;&#x63;&#x6f;&#109;">&#x74;&#x65;&#115;&#116;&#x2d;&#x75;&#115;&#101;&#x72;&#64;&#x65;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#x6d;</a>&rsquo;
password &lsquo;123456&rsquo;
password_confirmation &lsquo;123456&rsquo;
endIn this case the factory uses the default subdomain if it already exists, avoiding the validation problem.</p>

<p>Now if we use the initial code, it works without problem, assigning both users to the default subdomain</p>

<p>FactoryGirl.create(:user, :email =&gt; &ldquo;<a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x66;&#105;&#x72;&#115;&#x74;&#x40;&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#102;&#105;&#114;&#115;&#116;&#64;&#x65;&#120;&#97;&#x6d;&#x70;&#x6c;&#101;&#46;&#99;&#111;&#x6d;</a>&rdquo;)
FactoryGirl.create(:user, :email =&gt; &ldquo;<a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#115;&#x65;&#99;&#111;&#x6e;&#x64;&#x40;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;">&#x73;&#x65;&#x63;&#111;&#110;&#x64;&#x40;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#109;</a>&rdquo;)However this does not limit us to use the same subdomain for all users:</p>

<p>other_subdomain = FactoryGirl.create(:subdomain, :name =&gt; &ldquo;other-subdomain&rdquo;)</p>

<p>FactoryGirl.create(:user, :email =&gt; &ldquo;<a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#102;&#x69;&#x72;&#115;&#116;&#64;&#101;&#120;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#99;&#x6f;&#x6d;">&#102;&#105;&#114;&#115;&#x74;&#x40;&#101;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#109;</a>&rdquo;, :subdomain =&gt; other_subdomain)
FactoryGirl.create(:user, :email =&gt; &ldquo;<a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#x65;&#x63;&#111;&#110;&#100;&#x40;&#101;&#x78;&#x61;&#109;&#112;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;">&#115;&#101;&#x63;&#111;&#110;&#x64;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#x2e;&#x63;&#111;&#x6d;</a>&rdquo;)In this case, the first user is assigned to other-subdomain and the second user is assigned to test-subdomain.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/9/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/7/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/10/08/tong-guo-mongodumphe-mongorestoreshi-xian-mongodbbei-fen-he-hui-fu-by-chenzhou123520/">通过mongodump和mongorestore实现Mongodb备份和恢复 &#8211;by Chenzhou123520</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/10/06/ruby-on-rails-4-dot-0-release-notes/">Ruby on Rails 4.0 Release Notes</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/10/06/rails-active-record-named-scopes/">Rails Active Record Named Scopes</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/09/27/shai-shai-wo-men-de-kai-yuan-xiang-mu-iteyekai-yuan-dai-ma/">晒晒我们的开源项目 ITEYE开源代码</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/09/26/single-sign-on-dan-dian-deng-lu-sso/">Single Sign-on 单点登录 Sso</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/jhjguxin">@jhjguxin</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'jhjguxin',
            count: 10,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Francis Jiang -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
